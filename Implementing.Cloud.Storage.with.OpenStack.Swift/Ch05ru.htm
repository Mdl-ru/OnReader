<html>
<head>
   <link rel="icon" href="/i/MdlLogo.gif" type="image/gif">
   <title>Глава 5. Управление Swift. Реализация облачного хранилища с OpenStack Swift.</title>
   <meta name="Keywords" content="OpenStack, Cloud computing">
   <meta name="Description" content="Глава 5. Управление Swift. Реализация облачного хранилища с OpenStack Swift.">
   <meta name="Robots" content="INDEX, FOLLOW">
   <meta name="Author" content="Module-Projects,Ltd">
   <meta name="Copyright" content="Copyright 1998..2014 Module-Projects,Ltd">
   <meta http-equiv="Pragma" content="no-cache">
<script language="javascript" src="/css/v.0/mdlcss.js"></script>
<style type="text/css" media="screen, print">@import url("i/global-20140610.css");</style>
	<script language="javascript" src="http://www.mdl.ru/js/common.js"></script>
	<script language="javascript" src="http://www.mdl.ru/Solutions/ABC.js"></script>
<script language="javascript" src="/js/common.js"></script>
</head>
<body>

<table class="bg_White" width="1024" align="center" valign="top" border="0" cellpadding="0" cellspacing="0"><tbody>
<tr>
<td>
<table width="100%" border="0" cellpadding="2" cellspacing=0 class="bg_White"><tbody>
<tr>
<td width="150" valign="top" align="center"><img src="http://www.mdl.ru/RMC9.jpg" border=0 /></td>
<td width="724" valign="bottom" align="center">
<a class="item-t" href="http://www.mdl.ru"><img src="http://www.mdl.ru/i/MdlBigLogo.gif" border="0"></a><br/>
<a class="item-t" href="http://www.mdl.ru">С 1991 года на компьютерном рынке России</a>
</td>
<td align="center" valign="bottom">
<a class="item-t" href="javascript:tocall()" onmouseover="this.href=mail"><img src="http://www.mdl.ru/i/9563499.gif" border="0" alt="e-mail" /><br/><br/>т.: 676 0965, 676 0396<br/>Москва, Сосинская ул. 43, <br/>м. Волгоградский проспект</a>
</td>
</tr>
<tr>
<td class="big_16y" colspan="3" align="center"><a href="ToC.htm">Реализация облачного хранилища с OpenStack Swift.</a></td>
</tr>
<tr><td colspan="2">


<h2 align="right">ГЛАВА 5</h2>
<hr />
<h1 id="Chapter_05" align="right">Управление Swift.</h1>
<p>
После того, как кластер Swift был установлен и развернут, он должен быть управляемым, чтобы служить ожиданиям клиентов и соглашений об уровне обслуживания.
Поскольку в кластере Swift существует различные компоненты, управление слегка отличается и, следовательно, более сложным по сравнению с традиционными системами хранения.
Существует несколько инструментов и механизмов, которые администратор может использовать для эффективного управления кластером Swift. 
Эта глава посвящена более детальному рассмотрению данных проблем.
</p>

<h2 id="Ch0501">Повседневное управление</h2>
<p>
Кластер Swift состоит из нескольких узлов прокси-серверов и узлов серверов хранения.
Эти узлы выполняют многие процессы и службы для обеспечения работы кластера и выполнения заданий, а также поддержания общей доступности.
Для отслеживания состояния общих служб, загрузки процессора, использования памяти, производительности дисковой подсистемы и тому подобного можно запустить инструменты/ приложения общего управления сервером любого вида такие, например, как Nagios, который описан далее в данной главе.
Просмотр системных журналов является лучшим средством для обнаружения угроз отказов.
Наряду с этим, существуют некоторые инструменты для мониторинга конкретных служб Swift.
Некоторыми из них являются: Swift Recon, Swift StatsD, Swift Dispersion и Swift Informant.
</p><p>
Nagios является инфраструктурой мониторинга, которая включает различные плагинов (подключаемых программ), которые могут быть использованы для мониторинга сетевых сервисов (таких как HTTP и SSH), загруженности процессора, производительности и ресурсов, а также использования процессоров и дисков.
Она также обеспечивает возможности удаленного мониторинга с помощью выполнения сценариев (скриптов), которые удаленно подключаются к контролируемой системе с использованием SSH или SSL.
Пользователи могут создавать свои собственные плагины в зависимости от своих потребностей для расширения эти возможностей мониторинга.
Эти плагины могут быть написаны на нескольких языках, таких как Perl, Ruby, C++ и Python.
Nagios также обеспечивает механизм уведомления при использовании которого администратор может получать уведомлениея при возникновении проблем в системе.
На следующем рисунке показано, как интегрировать решение для мониторинга на основе Nagios:
	<div style="width: 600px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic05-01.jpg"  alt="Встраивание Nagios в Swift для мониторинга" title="Встраивание Nagios в Swift для мониторинга" width="600" height="536" style="width: 600px" />
		<span class="image-caption"></span>
	</p></div>
</p><p>
Дополнительная информация о Nagios может быть найдена на <a href="http://www.nagios.org">www.nagios.org</a>.
Далее давайте углубимся в детали инструментов мониторинга Swift.
</p>


<h3 id="Ch050101">Мониторинг кластера Swift</h3>
<p>
В этом разделе мы опишем различные инструменты, которые доступны для наблюдения за кластерами Swift.
Мы также покажем, снимки экранов мониторинга приложения Vedams Swift, которые объединяют данные из различных инструментов наблюдения за Swift.
</p>

<h4 id="Ch05010101">Swift Recon</h4>
<p>
Swift Recon является программным обеспечением промежуточного уровня, которое настраивается на узле сервера хранения объектов и располагается в информационных каналах.
Во время установки необходимо задать локальный каталог кэша, который используется для хранения журналов.
Он поставляется совместно с инструментом командной строки swift-recon, который может быть использован для доступа и отображения различных отслеживаемых показателей.
Для получения справки с помощью инструмента swift-recon вы можете воспользоваться вызовом <code>swift-recon -h</code>.
</p><p>
Приведем некоторые основные отслеживаемые метрики серверов:<ul>
 <li>Средние нагрузки
 <li>Данные <code>/proc/meminfo</code>
 <li>Смонтированные файловые системы
 <li>Размонтированные диски
 <li>Статистики разъемов
</ul> 
Одновременно с этим мониторятся также некоторые из следующих статистик Swift:<ul>
 <li>Контрольные суммы MD5checksum для колец учетных записей, контейнеров и объектов
 <li>Информация о репликациях
 <li>Число изолированных учетных записей, контейнеров и объектов
</ul>
</p><p>
Следующий скриншот показывает данные Swift Recon в рамках наблюдаемого приложения Vedams Swift
	<div style="width: 563px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic05-02.jpg"  alt="Отображение данных Swift Recon в рамках мониторинга приложения Vedams Swift" title="Отображение данных Swift Recon в рамках мониторинга приложения Vedams Swift" width="563" height="306" style="width: 563px" />
		<span class="image-caption"></span>
	</p></div>
</p><p>
</p>

<h4 id="Ch05010102">Swift Informant</h4>
<p>
Swift Informant также является программным обеспечением промежуточного уровня, которое дает понимание о клиентских запросах к прокси серверу.
Это программное обеспечение располагается в информационном канале прокси сервере и предоставляет серверу StatsD следующие метрики:<br />
 <li>Код состояния для запросов к учетным записей, контейнеров или объектов
 <li>Продолжительность запроса и время до появления метрики <code>start_response</code>
 <li>Число байт в переданном запросе
</a>
</p><p>
Следующий скриншот отображает данные Swift Informant в рамках мониторинга приложения Vedams Swift
	<div style="width: 560px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic05-03.jpg"  alt="Отображение данных Swift Informant в рамках мониторинга приложения Vedams Swift" title="Отображение данных Swift Informant в рамках мониторинга приложения Vedams Swift" width="560" height="304" style="width: 560px" />
		<span class="image-caption"></span>
	</p></div>
</p>

<h4 id="Ch05010103">Инструменты Swift dispersion</h4>
<p>
Этот инструмент завершающей обработки используется для определения общего состояния кластера Swift.
Инструмент  <code>swift-dispersion-populate</code> используется для распределения объектов и контейнеров по всему кластеру Swift таким образом, чтобы объекты и контейнеры попадали в различные разделы.
Далее выполняется инструмент <code>swift-dispersion-report</code> для определения состояния этих объектов и контейнеров.
В случае объектов, Swift делает три реплики для резервирования.
Если все копии объекта созданы успешно, то состояние объекта называется хорошим; инструмент <code>swift-dispersion-report</code> поможет выяснить таким образом состояние всех объектов и контейнеров в кластере.
</p><p>
Следующий скриншот отображает данные Swift Dispersion в рамках мониторинга приложения Vedams Swift
	<div style="width: 561px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic05-04.jpg"  alt="Отображение данных Swift Dispersion в рамках мониторинга приложения Vedams Swift" title="Отображение данных Swift Dispersion в рамках мониторинга приложения Vedams Swift" width="561" height="303" style="width: 561px" />
		<span class="image-caption"></span>
	</p></div>
</p>

<h4 id="Ch05010104">StatsD</h4>
<p>
Службы Swift были оборудованы средствами для отправки статистик (счетчиков и регистрационных записей) непосредственно в настраиваемый сервер StatsD.
</p><p>
Простой демон StatsD для приема метрик может быть найден на <a href="https://github.com/etsy/statsd/">https://github.com/etsy/statsd/</a>
</p><p>
Метрики StatsD собираются в режиме реального времени и могут помочь с идентификацией проблем в случае их возникновения.
Для предоставлении возможности ведения протоколов StatsD в файлах настройки Swift должны быть установлены файлы настройка, содержащие следующие параметры: <ul>
 <li><code>log_statsd_host</code>
 <li><code>log_statsd_port</code>
 <li><code>log_statsd_default_sample_rate</code>
 <li><code>log_statsd_sample_rate_factor</code>
 <li><code>log_statsd_metric_prefix</code>
</ul>
</p><p>
Параметр <code>log_statsd_sample_rate_factor</code> может быть отрегулирован для установки необходимой частоты протоколирования.
Параметр <code>log_statsd_metric_prefix</code> устанавливается на узле для подстановки этого префикса во все отправляемые на сервер StatsD с этого узла метрики.
Если параметр <code>log_statsd_host</code> не установлен, то данная функциональность буде отключена.
</p><p>
Журналы StatsS могут пересылаться на внутренний сервер Graphite для отображения метрик в виде графиков.
Следующий снимок экрана мониторинга приложения Vedams Swift представляет журналы StatsD в виде графиков:
	<div style="width: 559px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic05-05.jpg"  alt="Мониторинг приложения Vedams Swift представленный в виде графиков журналов StatsD" title="Мониторинг приложения Vedams Swift представленный в виде графиков журналов StatsD" width="559" height="301" style="width: 559px" />
		<span class="image-caption"></span>
	</p></div>
</p>

<h4 id="Ch05010105">Метрики Swift</h4>
<p>
Исходный код Swift имеет встроенные в него метрики протоколирования (счетчики, хронометражи и тому подобные).
Некоторые из отправляемых на сервер StatsD из различных служб Swift метрик перечислены в следующей таблице.
Они были разделены на группы на основе операций <strong>создания, чтения, обновления, удаления</strong>
(CRUD, Create, Read, Update, Delete):
<table style="border: none; align=center;" align="center" cellspacing="0" cellpadding="0"><tbody>
<tr>
 <td width="25%" style="border-top: thin solid; border-bottom: thin solid; align=center;">Create/PUT
 <td width="25%" style="border-top: thin solid; border-bottom: thin solid; align=center;">Read/GET
 <td width="25%" style="border-top: thin solid; border-bottom: thin solid; align=center;">Update/POST
 <td width="25%" style="border-top: thin solid; border-bottom: thin solid; align=center;">Delete
</tr><tr>
 <td>account-server.PUT.errors.timing
 <td>account-server.GET.errors.timing
 <td>account-server.POST.errors.timing
 <td>account-server.DELETE.errors.timing
</tr><tr>
 <td>account-server.PUT.timing
 <td>account-server.GET.timing
 <td>account-server.POST.timing
 <td>account-server.DELETE.timing
</tr><tr>
 <td>container-server.PUT.errors.timing
 <td>container-server.GET.errors.timing
 <td>container-server.POST.errors.timing
 <td>container-server.DELETE.errors.timing
</tr><tr>
 <td>container-server.PUT.timing
 <td>container-server.GET.timing
 <td>container-server.POST.timing
 <td>container-server.DELETE.timing
</tr><tr>
 <td>object-server.async_pendings
 <td>&nbsp;
 <td>&nbsp;
 <td>object-server.async_pendings
</tr><tr>
 <td>object-server.PUT.errors.timing
 <td>object-server.GET.errors.timing
 <td>object-server.POST.errors.timing
 <td>object-server.DELETE.errors.timing
</tr><tr>
 <td>object-server.PUT.timeouts
 <td>&nbsp;
 <td>&nbsp;
 <td>&nbsp;
</tr><tr>
 <td>object-server.PUT.timing
 <td>object-server.GET.timing
 <td>object-server.POST.timing
 <td>object-server.DELETE.timing
</tr><tr>
 <td>object-server.PUT.&lt;device&gt;.timing
 <td>&nbsp;
 <td>&nbsp;
 <td>&nbsp;
</tr><tr>
 <td>proxy-server.&lt;type&gt;.client_timeouts
 <td>&nbsp;
 <td>&nbsp;
 <td>&nbsp;
</tr><tr>
 <td>proxy-server.&lt;type&gt;.client_disconnects
 <td>&nbsp;
 <td>&nbsp;
 <td>&nbsp;
</tr><tr>
 <td>proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.timing
 <td>proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.timing
 <td>proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.timing
 <td>proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.timing
</tr><tr>
 <td style="border-bottom: thin solid;">proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.xref
 <td style="border-bottom: thin solid;">proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.xref
 <td style="border-bottom: thin solid;">proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.xref
 <td style="border-bottom: thin solid;">proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.xref
</tr></tbody></table>
<em>(Прим.пер.: по сравнению с оригиналом в предыдущей таблице произведено смысловое построчное выравнивание.)</em>
</p>


<h2 id="Ch0502">Ведение журналов с помощью rsyslog</h2>
<p>
На практике очень полезно получать журналы от различных служб Swift, что может быть достигнуто путем настройки <code>proxy-server.conf</code> и </code>Rsyslog</code>.
Для того, чтобы получать журналы с прокси сервера, мы изменяем настройку файла <code>/etc/swift/proxy-server.conf</code>, добавив следующие строки:
<br /><code>
log_name = name<br />
log_facility = LOG_LOCALx<br />
log_level = LEVEL
</code>
</p><p>
Опишем предыдущие записи: <code>name</code> может быть любым именем, которое вы хотели бы видеть в журналах.
Символ <code>X</code> в <code>LOG_LOCALx</code> может быть любым числом от нуля до семи.
LEVEL (параметр уровня) может быть одним из: <code>emergency</code>, <code>alert</code>, <code>critical</code>, <code>error</code>, <code>warning</code>, <code>notification</code>, <code>informational</code> или <code>debug</code> (чрезвычайная ситуация, предупреждение, критическая ситуация, ошибка, предупреждение, уведомление, информационное или отладка).
</p><p>
Далее изменим <code>/etc/rsyslog.conf</code> добавив следующую строку кода в раздел <code>GLOBAL_DIRECTIVES</code>
<br /><code>
$PrivDropToGroup adm
</code>
</p><p>
Также мы создадим файл настройки <code>/etc/rsyslog.d/swift.conf</code> и добавим в него следующую строку кода:
<br /><code>
local2.* &nbsp; &nbsp; &nbsp; /var/log/swift/proxy.log
</code>
</p><p>
Предыдущая строка сообщает syslog, что любая регистрационная запись в устройство <code>LOG_LOCAL2</code> должна быть отправлена в файл <code>/var/log/swift/proxy.log</code>.
Затем мы предоставляем права доступа к папке <code>/var/log/swift</code> и перезапускаем службу прокси сервера и службу syslog.
</p>


<h2 id="Ch0503">Управление отказами</h2>
<p>
В этом разделе мы имеем дело с обнаружением сбоев и действия по устранению неисправностей.
Это могут быть отказы диска, сервера, зоны, или даже региона.
Как описано в <em><a href="Ch02ru.htm">Главе 2, Архитектура OpenStack Swift</a></em> в ходе обсуждения теоремы CAP, Swift предназначен быть доступным и устойчивым к частичным отказам (при которых из строя могут выходить целые части кластера).
</p>

<h3 id="Ch050301">Определение дисковых отказов</h3>
<p>
Журналы ядра являются хорошим местом для поиска дисковых отказов.
Дисковая система будет создавать учетные записи предостережений или ошибок, которые могут помочь администратору определить: являются ли диски плохо работающими или уже вышли из строя.
На узлах хранения мы также можем создать скрипт для перехвата информации о дисковых отказах с сипользованием процесса аудита устройств, описанного в <em><a href="Ch02ru.htm">Главе 2, Архитектура OpenStack Swift</a></em> выполнив следующие шаги:<ol>
 <li>на каждом узле хранения создайте скрипт swift-drive-audit в каталоге <code>/etc/swift</code> со следующим содержанием:
<br /><code>
[drive-audit]
log_facility = LOG_LOCAL0<br />
log_level = DEBUG<br />
device_dir = /srv/node<br />
minutes = 60<br />
error_limit = 2<br />
log_file_pattern = /var/log/kern*<br />
regex_pattern_X = berrorb.*b(sd[a-z]{1,2}d?)b and b(sd[a-z]{1,2}d?)b.*berrorb
</code>
 <li>Добавьте следующую строку кода в <code>/etc/rsyslog.d/swift.conf:</code>
<br /><code>
local0.* /var/log/swift/drive-audit
</code>
 <li>Затем перезапустите службу rsyslog с использованием следующей команды:
<br /><code>
# Service rsyslog restart
</code>
 <li>После этого перезапустите службу Swift с использованием следующей команды:
<br /><code>
# swift-init rest restart
</code>
 <li>Информация о дисковых отказах теперь будет сохраняться в файле журналов <code>/var/log/swift/drive-audit</code>
</ol>
</p>

<h3 id="Ch050302">Обработка дисковых отказов</h3>
<p>
При возникновении неисправности одного диска, мы можем либо заменить диск быстро, в более позднее время или не заменять его совсем.
Если мы не планируем немедленную замену диска, то лучше будет отключить привод и удалить его из кольца. 
Если мы решили заменить диск, то мы возьмем вышедший из строя диск и заменим его с хорошим диском, отформатировав и смонтировав его.
Мы позволим алгоритму репликации позаботиться о заполнении этого диска данными для поддержки согласованных реплик и целостности данных.
</p>

<h3 id="Ch050303">Обработка отказов узлов</h3>
<p>
Если сервер хранения в кластере Swift испытывает проблемы, мы должны определить может ли проблема быть устранена в короткий промежуток времени, например, за пару часов, или это займет длительный период времени.
Если интервал времени простоя мал, то мы можем позволить службам Swift работать совместно с вышедшим из строя узлом на протяжении времени, в течение которого мы проводим отладку и устраняем проблему с ним.
Поскольку Swift поддерживает несколько реплик данных (по умолчанию три), не будет проблемы доступностью данных, но хрометражи для доступа к данным могут увеличиться.
Как только проблема будет найдена и устранена, а узел возвращаен в строй, службы репликации Swift будут позаботятся о выяснении наличия утраченной информации и обновят узлы, а также произведут их синхронизацию.
</p><p>
Если время восстановления значительное, то лучше удалить узел и все связанные с ним устройства из кольца.
Как только узел будет возвращен назад к работе, устройства могут быть отформатированы, повторно смонтированы и добавлены назад в кольцо.
</p><p>
Следующие две команды будут полезны для удаления устройств и узлов из кольца: <ul>
 <li>Для удаления устройства из кольца используйте:
<br /><code>
# swift-ring-builder &lt;builder-file&gt; remove &lt;ip_address&gt;/&lt;device_name&gt;
</code>
<br />
Например, <code>swift-ring-builder account.builder remove 172.168.10.52/sdb1</code>.
 <li>Для удаления из кольца сервера воспользуйтесь:
<br /><code>
# swift-ring-builder &lt;builder-file&gt; remove &lt;ip_address&gt;
</code>
Например, <code>swift-ring-builder account.builder remove 172.168.10.52</code>.
</ul>
</p>

<h4 id="Ch05030301">Отказ сервера прокси</h4>
<p>
Если в кластере присутствует только один прокси-сервер, и он отказал, то существует вероятность того, что никакие объекты не будут доступны (или загружены) клиентом, так что это потребует немедленного внимания.
Вот почему всегда будет хорошей идеей иметь резервный прокси-сервер для повышения доступности данных в кластере Swift.
После выявления и устранения отказа в прокси-сервере, перезапускаются службы Swift и восстанавливается доступ к системе хранения объектов.
</p>

<h3 id="Ch050304">Отказ зоны и региона</h3>
<p>
В случае сбоя целой зоны, все еще возможно не прекращать службы Swift за счет настроек высокой доступности, которые содержат множество узлов хранения и несколько зон.
Если отказ может быть отлажен быстро, то серверы хранения данных и приводы, находящиеся на отказавшем узле, должны быть возвращены в рабочее состояние.
В противном случае, принадлежащие к зоне серверы хранения и приводы должны быть удалены из кольца, а кольцо должно быть повторно сбалансировано.
После того, как зона вернется в рабочее состояние, диски и серверы хранения данных могут быть добавлены в кольцо и кольцо может быть снова сбалансировано.
В общем, отказавшая зона должна быть рассмотрена как критическая проблема.
В некоторых случаях может отказать находящаяся в вершине стойки система хранения или сетевой коммутатор, тем самым отключив ведущие к отказавшей зоне массивы хранения данных и сервера от кластера Swift.
В этих случаях, отказавший коммутатор должен быть быстро продиагностирован и возвращен в рабочее состояние.
</p><p>
В случае инсталяции с множеством регионов, при отказе региона все запросы могут быть перенаправлены в продолжающие работать регионы.
Серверы и накопители, которые принадлежат этому региону должны быть быстро возвращены в рабочее состояние для сбалансирования нагрузки, которая в настоящее время обрабатывается оставшимися в строю регионами.
Другими словами, этот отказ следует рассматривать как проблему блокировки.
Могут существовать задержки, наблюдаемые при выгрузке и загрузке из-за того, что запросы направляются в различные регионы.
Отказы регионов также могут произойти из-за неисправностей, возникающих в маршрутизаторах ядра или межсетевых экранах (брэндмауэрах).
Эти отказы также следует быстро диагностировать и устранять, чтобы вернуть регион в рабочее состояние.
</p>


<h2 id="Ch0504">Планирование емкости</h2>
<p>
По мере роста числа клиентов, начанающих работу с кластером Swift, это увеличивает потребность в дополнительных системах хранения.
При использовании Swift, это легко выполнимо; вы можете просто добавить несколько узлов хранения и связанные с ними прокси-серверы.
В этом разделе рассматриваются вопросы планирования и добавления новых накопителей, а также серверов хранения данных.
</p>

<h3 id="Ch050401">Добавление новых устройств</h3>
<p>
Хотя добавление новых дисков является простым процессом, он требует тщательного планирования, так как это предполагает повторную балансировку кольца.
После того, как мы решили добавить новые диски, мы добавим эти диски к определенному серверу хранения в зоне выпонив форматирование и монтирование этих дисков.
Далее, мы выполним команду swift-ring-builder <code>add</code> для добавления этих дисков в кольцо. 
Наконец, для выполнения ребалансировки кольца мы запустим команду <code>swift-ring-builder rebalance</code>.
Созданные файлы кольца <code>.gz</code> должны быть распространены по всем узлам серверов хранения данных.
Команды для выполнения этих операций были объяснены в <a href="Ch03ru.htm"><em>Главе 3. Установка OpenStack Swift</em></a>, в разделах <a href="Ch03ru.htm#Ch03020302"><em>Форматирование и монтирование дисков</em></a> и <a href="Ch03ru.htm#Ch030205"><em>Установка кольца</em></a>.
</p><p>
Часто, мы в конечном итоге заменяем старые диски более лучшими дисками бОльшего размера.
В этом случаевместо выполнения внезапного перемещния лучше начать медленую мигрирацию данных со старого диска на другие диски, путем уменьшения веса данного диска в кольце и повторения этого шага несколько раз.
После того, как данные были перенесены с этого диска, он может быть безопасно удален.
После удаления старого диска, просто вставьте новый диск и следуйте упомянутым ранее действиям, чтобы добавить этот диск в кольцо.
</p>

<h3 id="Ch050402">Добаваление новых систем хранения и серверов прокси</h3>
<p>
Добавление новых систем хранения и серверов прокси также является несложной операцией, при которой новые сервера должны быть подготовленыв в соответствии с инструкциями, предоставленными в <a href="Ch03ru.htm"><em>Главе 3. Установка OpenStack Swift</em></a>.
Сервера хранения должны быть помещены в правильные зоны, а расположенные на них диски должны быть размещены в кольце.
После перебалансровки и распространения файлов кольца <code>.gz</code> на остальные сервера хранения, новые сервера хранения становятся частью кластера.
Аналогично, после установки нового прокси сервера, файлы настройки и установки балансировки нагрузки подлежат обновлению.
Такой прокси сервер теперь является частью кластера и может принимать запросы от пользователей.
</p>


<h2 id="Ch0505">Миграции</h2>
<p>
Данный раздел связан с миграциями аппартаных и программных средств.
Миграции могут выполняться на существующие сервера или на новые сервера в пределах зоны или региона.
Как только новые аппаратные средства или программное обеспечение (операционная система, пакеты или программное обеспечение Swift) становятся доступными, существующие сервера и установленное программное обеспечение должны выполнить миграцию для получения преимуществ от более быстрой скорости процессора или последних обновлений прграммного обеспечения.
Хорошаяидея состоит в обновлении одного сервера за раз и одной зоны за раз, поскольку службы Swift могут выполнять миграцию сразу для всей зоны. 
</p><p>
Для обновления узла сервера хранения требуются следующие шаги:<ol>
 <li>Выполните следующие команды для остановки запущенных в фоновом режиме операций Swift:<br />
<strong><code>
# swift-init rest stop
</code></strong>
 <li>Аккуратно остановите все службы Swift с использованием следующей команды:<br />
<strong><code>
# swift-init {account|container|object} shutdown
</code></strong>
 <li>Выполните обновление необходимых операционной системы и пакетов системного программного обеспечения и установите/ обновите необходимые пакеты Swift.
Как правило, Swift находится в рамках шестимесячного цикла обновления.
 <li>Затем создайте файлы настройки Swift или выполните необходимые изменения.
 <li>После перезагрузки сервера перезапустите все необходимые службы выполнив следующие команды:<br />
<strong><code>
# swift-init {account|container|object} start<br />
# swift-init rest start
</code></strong>
</ol>
</p><p>
Если  в отношении к дисков на сервере хранения существуют изменения, то мы должны убедиться, что мы обновили и сбалансировали кольцо.
</p><p>
После того как мы завершили переход на новый сервер, мы проверяем файлы журнала на корректность работы сервера.
Если сервер работает без каких-либо проблем, далее мы приступаем к модернизации следующего сервера хранения.
</p><p>
Далее мы рассмотрим как обновлять прокси- серверы.
Мы можем воспользоваться балансировкой нагрузки для изоляции прокси-сервера, который мы планируем обновить таким образом, чтобы клиентские запросы не отправлялись на данный прокси- сервер.
</p><p>
Для выполнения обновления прокси- сервера мы выполняем следующие шаги:<ol>
 <li>Аккуратно остановите все прокси- службы с использованием следующей команды:<br />
<strong><code>
# swift-init proxy shutdown
</code></strong>
 <li>Обновите необходимые операционную систему, пакеты системного программного обеспечения, а также установите/ обновите требующиеся пакеты Swift.
 <li>Далее создайте файлы настройки Swift или выполните необходимые изменения.
 <li>После перезагрузки сервера запустите все необходимые службы с использованием следующей команды:<br />
<strong><code>
# swift-init proxy start
</code></strong>
</ol>
</p><p>
Затем мы должны убедиться, что мы добавили обновленный прокси- сервер назад в пул балансировки нагрузки с тем, чтобы он смог приступить к приему запросов от клиентов.
</p><p>
После обновления мы должны убедиться путем просмотра журналов, что прокси серверы работают корректно.
</p>


<h2 id="Ch0506">Заключение</h2>
<p>
В данной главе вы изучили как управлять кластером Swift, различные доступные для мониторинга и управления кластером Swift инструменты, а также различные метрики для определения состояния кластера.
Также вы ознакомились с тем, какие действия должны быть предприняты в случае отказа компонентов кластера, а также как можно расширять кластер путем добавления новых дисков и узлов.
</p>

<table width="100%" border="0" cellpadding="2" cellspacing=0 class="bg_White"><tbody><tr>
 <td align="left"><a href="Ch04ru.htm">Глава 4</a></td>
 <td align="center"><a href="ToC.htm">Оглавление</a></td>
 <td align="right"><a href="Ch06ru.htm">Глава 6</a></td>
</tr><tr><td colspan="3" style="border-bottom: thin solid;">&nbsp;</tr>
<tr><td colspan="2" valign="top">Перевод: Copyright ©&nbsp;2014 &nbsp;<img src="/i/mdl-reg.jpg" widht="35" height="12" style="border-style: none;">.<br>
All rights reserved.<br />
Ссылки обязательны (Refs and links obligatory).</td>
<td valign="top" align="right"><em><a href="http://www.mdl.ru">http://www.mdl.ru</a></em></td></tr>
</tbody></table>


<td align="right" valign="top">
<script language="javascript">
WriteABC('GPFS');
//--></script>
</tr>
</tbody></table>
</body>
</html>
