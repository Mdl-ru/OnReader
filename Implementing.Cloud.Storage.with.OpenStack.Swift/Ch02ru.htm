<html>
<head>
   <link rel="icon" href="/i/MdlLogo.gif" type="image/gif">
   <title>Глава 2. Архитектура OpenStack Swift. Реализация облачного хранилища с OpenStack Swift.</title>
   <meta name="Keywords" content="OpenStack, Cloud computing">
   <meta name="Description" content="Глава 2. Архитектура OpenStack Swift. Реализация облачного хранилища с OpenStack Swift.">
   <meta name="Robots" content="INDEX, FOLLOW">
   <meta name="Author" content="Module-Projects,Ltd">
   <meta name="Copyright" content="Copyright 1998..2014 Module-Projects,Ltd">
   <meta http-equiv="Pragma" content="no-cache">
<script language="javascript" src="/css/v.0/mdlcss.js"></script>
<style type="text/css" media="screen, print">@import url("i/global-20140610.css");</style>
<script language="javascript" src="http://www.mdl.ru/usd.js"></script>
	<script language="javascript" src="http://www.mdl.ru/js/common.js"></script>
	<script language="javascript" src="http://www.mdl.ru/Solutions/ABC.js"></script>
</head>
<body>

<table class="bg_White" width="1024" align="center" valign="top" border="0" cellpadding="0" cellspacing="0"><tbody>
<tr>
<td>
<table width="100%" border="0" cellpadding="2" cellspacing=0 class="bg_White"><tbody>
<tr>
<td width="150" valign="top" align="center"><img src="http://www.mdl.ru/RMC9.jpg" border=0 /></td>
<td width="724" valign="bottom" align="center">
<a class="item-t" href="http://www.mdl.ru"><img src="http://www.mdl.ru/i/MdlBigLogo.gif" border="0"></a><br/>
<a class="item-t" href="http://www.mdl.ru">С 1991 года на компьютерном рынке России</a>
</td>
<td align="center" valign="bottom">
<a class="item-t" href="javascript:tocall()" onmouseover="this.href=mail"><img src="http://www.mdl.ru/i/9563499.gif" border="0" alt="e-mail" /><br/><br/>т.: 676 0965, 676 0396<br/>Москва, Сосинская ул. 43, <br/>м. Волгоградский проспект</a>
</td>
</tr>
<tr>
<td class="big_16y" colspan="3" align="center"><a href="ToC.htm">Реализация облачного хранилища с OpenStack Swift.</a></td>
</tr>
<tr><td colspan="2">



<h2 align="right">ГЛАВА 2</h2>
<hr />
<h1 id="Chapter_02" align="right">Архитектура OpenStack Swift.</h1>
<p>
OpenStack Swift является магией, которая преобразует набор несвязных общедоступных серверов в масштабируемую, долговечную, простую в управлении систему хранения.
Мы будем детально рассматривать архитектуру Swift (в редакции Havana).
Вначале мы взглянем на логическую организации объектов, а затем на то, как Swift полностью виртуализирует это представление и отображает его на физическое оборудование.
<table align= "center"><tbody><tr>
<td style="font-size: 36pt;">[<img src="i/Notes.jpg" width="36" height="31"></td>
<td align= "center">Заметим, что мы используем термины <strong>долговечный</strong> и <strong>надежный</strong><br /> как синонимы (<strong>durable</strong> и <strong>reliable</strong>)</td>
<td style="font-size: 36pt;">]</td>
</tr></tbody></table>
</p>

<h2 id="Ch0201">Логическая организация объектов</h2>
<p>
Для начала давайте ознакомимся с логической организации объектов, а затем посмотрим как Swift полностью абстрагирует и отображает объекты физического оборудования.
</p><p>
Владельцу назначается учетная запись.
Владельцем может быть любой объект — субъект, отдел, компания и так далее.
Учетная запись содержит контейнеры. 
Каждый контейнер содержит объекты, как показано в следующем рисунке.
Вы можете представлять объекты файлами по существу.
	<div style="width: 434px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic02-01.jpg"  alt="Логическая организация объектов в Swift" title="Логическая организация объектов в Swift" width="434" height="311" style="width: 434px" />
		<span class="image-caption">Логическая организация объектов в Swift</span>
	</p></div>
<p>
Владелец может создать дополнительных пользователей для доступа к учетной записи.
Пользователи могут продолжать добавлять контейнеры и объекты в контейнер без необходимости заботы о каких-либо физических пределах аппаратного обеспечения, в отличие от обычных файловых или блочных систем хранения.
Контейнеры в учетной записи, безусловно, должны иметь уникальное имя, но два контейнера в различных учетных записях могут иметь одно имя.
Контейнеры являются плоскими, а объекты не сохраняются иерархически, в отличие от того, как файлы хранятся в файловой системе, в которой каталоги могут быть вложенными.
Тем не менее, Swift предусматривает механизм для имитации <strong>псевдо-каталогов</strong>, вставляя разделитель / в имя объекта.
</p>

<h2 id="Ch0202">Реализация Swift</h2>
<p>
Существуют две основные подлежащие решению проблемы Swift:
<ul>
 <li>Где размещать и откуда извлекать данные
 <li>Как надежно сохранять данные
</ul>
Мы изучим последующие разделы, чтобы полностью понять эти две проблемы.
</p>

<h3 id="Ch020201">Ключевые принципы архитектуры</h3>
<p>
Некоторые ключевые архитектурные принципы, лежащие в основе Swift, заключаются в следующем:<ul>
 <li><strong>Отсутствие ведущего</strong>: ведущий одновременно создает в системе единую точку отказа и узкое место для производительности.
  Система без главного исключает это обстоятельство, а также позволяет нескольким участникам кластера отвечать на API запросы.
 <li><strong>Свобода от закрепления</strong>: Нет необходимости в жестких связях в кластере.
  Это также является необходимым условием для предотвращения узких мест в производительности и отказах.
 <li><strong>Распределение нагрузки</strong>: Нельзя достигнуть производительности, производительность, ведения учетных записей, емкость и масштабируемость объектов не могут быть достигнуты.
 <li><strong>Самовосстановление</strong>:
  Система должна автоматически регулировать сбои оборудования.
  В соответствии с обсуждавшейся в главе 1 <em><a href="Ch01ru.htm">Облачное хранилище: Почему я не могу быть как Google?</a></em> теореме CAP должны допускаться частичные допуски.
 <li><strong>Организация данных</strong>:
  Ряд систем хранения объектов просто возвращают хэш-ключи для представленного объекта и обеспечивают полностью плоское пространство имен.
  Задача создания учетных записей, контейнеров и ключей соответствия именам объектов остается за пользователем.
  Swift упрощает работу пользователя и обеспечивает хорошо разработанный уровень организации данных.
 <li><strong>Доступность и согласованность в конечном счете</strong>:
  Об этом шла речь в главе 1 <em><a href="Ch01ru.htm">Облачное хранилище: Почему я не могу быть как Google?</a></em>
</ul> 
</p>

<h3 id="Ch020202">Организация физических данных</h3>
<p>
Swift полностью абстрагирует логическую организацию данных от их физической организации.
На физическом уровне Swift классифицирует физическое местоположение в иерархии, как это показано на следующем рисунке:
	<div style="width: 501px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic02-02.jpg"  alt="Иерархия расположения физических данных" title="Иерархия расположения физических данных" width="501" height="438" style="width: 501px" />
		<span class="image-caption">Иерархия расположения физических данных</span>
	</p></div>
<ul>Иерархия заключается в следующем:
 <li><strong>Регион</strong>:
На самом высоком уровне Swift хранит данные в регионах, которые географически разделены и, таким образом, претерпевают высокие задержки при связи.
Пользователь может использовать только один регион, например, если кластер использует только один центр обработки данных.
 <li><strong>Зона</strong>:
В регионах существуют зоны.
Зоны являются набором узлов хранения, которые совместно используют различные характеристики доступности.
Доступность может быть определена различными: физическими зданиями, источниками питания или сетевыми соединениями.
Это означает, что зоной может быть отдельный сервер хранения, стойка, или весь центр обработки данных в зависимости от ваших потребностей.
Зоны должны быть соединены друг с другом с помощью низкой латентностью ссылки.
Rackspace рекомендует иметь по крайней мере пять зон каждого региона.
 <li><strong>Серверы хранения данных</strong>:
Зона состоит из множества серверов хранения в пределах от всего одного сервера до нескольких стоек.
 <li><strong>Диск</strong> (или устройство):
Дисковые накопители являются частью сервера хранения.
Это могут располагаться внутри сервера или подключаться через JBOD.
</ul></p><p>
Swift будет хранить несколько <strong>реплик</strong> (копий, по умолчанию = 3) объекта на разных дисках.
С использованием алгоритма в уникальный-насколько-это-возможно (as-unique-as-possible), эти реплики располагаются настолько &quot;далеко&quot; друг от друга, как это возможно в смысле различных регионов, зон, серверов хранения и дисков.
Этот алгоритм отвечает за вопросы надежности Swift.
</p><p>
Swift использует полустатическую таблицу для поиска места размещения объектов и их копий.
Онаявляется полустатической, поскольку таблица поиска под названием &quot;кольцо&quot; в Swift создается с помощью внешнего процесса, называемого <strong>конструктором кольца</strong> (ring builder).
Кольцо может быть изменено, однако не динамически, и никогда самим Swift.
Оно не является распределенным, следовательно каждый занимающийся размещением данных узел имеет полную копию кольца.
Кольцо имеет внутри себя записи, называемые <strong>разделами</strong> (partition, этот термин не следует путать с более часто используемым названием для дисковых разделов).
По сути, объект отображается в разделе, а раздел предоставляет устройства, вкоторых должны быть сохранены реплики объекта.
Кольцо также предоставляет список автоматически переназначаемых устройств, на случай если любое из исходных устройств испытывает отказ.
</p><p>
Фактическое сохранение объекта осуществляется в файловой системе, которая находится на диске, например, в XFS.
Информация об учетных записях и контейнерах хранится в базе данных SQLite.
База данных учетных записей содержит список всех контейнеров, а база данных контейнеров содержит список всех его объектов.
Эти базы данных хранятся в отдельных файлах, причем файлы реплицируются так же, как и любой другой объект.
</p>

<h3 id="Ch020203">Программные серверы информационных каналов</h3>
<p>Информационные каналы состоят из следующих четырех серверов программного обеспечения:<ul>
 <li>Прокси сервер
 <li>Сервер учетных записей
 <li>Сервер контейнеров
 <li>Сервер объектов
</ul></p><p>
Если вам необходима высокая производительность, то серверы учетных записей, контейнеров и объектов часто располагаются на одном физическом сервере, который называется <strong>сервером хранения</strong> (или узлом), как показано на следующем рисунке:
	<div style="width: 827px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic02-03.jpg" alt="Программные серверы информационных каналов (сервер хранения включает в себя серверы учетных записей, контейнеров и объектов)" title="Программные серверы информационных каналов (сервер хранения включает в себя серверы учетных записей, контейнеров и объектов)" width="827" height="322" style="width: 827px" />
		<span class="image-caption">Программные серверы информационных каналов (сервер хранения включает в себя серверы учетных записей, контейнеров и объектов)</span>
	</p></div>
<ul>Ниже приводится описание каждого типа сервера:
 <li><strong>Прокси-сервер</strong>:
Прокси-сервер отвечает за принятие HTTP запросов от пользователя.
Он выполнит поиска местоположения сервера(ов) хранения, куда должен быть направлен запрос с использованием кольца.
Прокси-сервер отвечает за отказы (путем поиска узлов для автоматического переназначения) и выполняет операции сродства чтения/записи (путем отправки записей или чтений в тот же регион; см. разделы <a href="#Ch02020301">Один день из жизни операций создания</a> и <a href="#Ch02020302">Один день из жизни операций чтения</a>).
Когда объекты устремиляются к серверу объектов или с него, они также протекают непосредственно через прокси-сервер.
Кроме того, прокси-серверы также отвечают за кворум чтения/записи и часто размещают встроенное программное обеспечение промежуточного уровня (что обсуждается далее в этой главе).
 <li><strong>Сервер учетных записей</strong>:
Сервер учетных записей отслеживает имена контейнеров для конкретной учетной записи.
Данные хранятся в базе данных SQLite; файлы базы данных в дальнейшем хранятся в файловой системе.
Этот сервер также отслеживает статистику, однако не имеет никакой информации о местоположении контейнеров.
Информация о местоположении определяется прокси-сервером на основе данных кольца.
Обычно этот сервер размещен на одном физическом сервере с серверами контейнеров и объектов.
Тем не менее, для крупных установок может потребоваться отдельнsq физический сервер.
 <li><strong>Сервер контейнеров</strong>:
Этот сервер очень похож на сервер учетных записей, за исключением того, что он имеет дело с именами объектов в определенном контейнере.
 <li><strong>Сервер объектов</strong>:
Сервер объектов просто хранит объекты.
Каждый диск имеет свою файловую систему, и объекты сохраняются вэтой файловой системе.
</ul></p><p>
Давайте сошьем физическую организацию данных с различными программными компонентами и исследуем четыре основные операции: создание, чтение, обновление и удаление (известные как CRUD: create, read, update и delete).
Для простоты, мы сосредоточимся на сервере объектов, однако рассмотрение также можно дополнительно экстраполировать на оба сервера учетных записей и контейнеров.
</p>

<h4 id="Ch02020301">Один день из жизни операций создания</h4>
<p>
Запрос <code>create</code> отправляется через API вызов HTTP PUT на прокси-сервер.
Нет значения какой прокси-сервер получает запрос, так как Swift является распределенной системой и все прокси-серверы созданы равноправными.
Прокси-сервер взаимодействует с кольцом для получения списка дисков и связанных с ними серверов объектов для записи данных.
Как мы уже обсуждали ранее, эти диски будут по- возможности уникальными.
В случае отказа некоторых дисков или их недоступности, кольцо предоставляет автоматически замещаемые устройства.
После того, как большинство дисков подтвердили запись (например, два из трех дисков), операция возвращается как успешная.
Если предположить, что оставшиеся записи завершились успешно, то у нас все хорошо.
Если нет, то процесс репликации, как это показано на следующем рисунке, обеспечивает в конечном счете создание остальных копий:
	<div style="width: 832px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic02-04.jpg" alt="Один день из жизни операций создания" title="Один день из жизни операций создания" width="832" height="393" style="width: 832px" />
		<span class="image-caption">Один день из жизни операций создания</span>
	</p></div>
</p><p>
Операция <code>create</code> работает немного по-другому в кластере с несколькими регионами.
Все копии объекта записываются в локальном регионе.
Это называется <strong>афинной записью</strong> (write affinity, близкой записью).
Затем объект асинхронно перемещается в другую область (области).
Для этой операции может быть использована выделенная сети репликации.
</p>

<h4 id="Ch02020302">Один день из жизни операций чтения</h4>
<p>
Запрос <code>read</code> посылается к прокси-серверу через API вызов HTTP <code>GET</code>.
Как и в предыдущем случае, любой прокси-сервер может получить этот запрос.
Как и при операции <code>create</code>, прокси-сервер взаимодействует с кольцом для получения списка дисков и связанных с ними серверов объектов.
Запрос <code>read</code> выдается серверам объектов в том же регионе где расположен прокси-сервер.
Это называется  <strong>афинным чтением</strong> (read affiity, близким чтением).
Для реализации с множеством регионов, согласованность, в конечном итоге, представляет собой проблему, поскольку разные регионы могут иметь различные версии объекта.
Для решения этой проблемы, может быть запрошена операция <code>read</code> для объекта с последней временной отметкой.
В этом случае, прокси-серверы вначале запрашивают временные отметки от всех серверов объектов и читают данные с сервера с новейшей копией.
Как и в случае операции <code>create</code> (<em>прим. пер.: в тексте оригинала <code>write</code></em>), в случае отказа может быть запрошено автоматически замещаемое устройство.
</p>

<h4 id="Ch02020303">Один день из жизни операций обновления</h4>
<p>
Запрос <code>update</code> обрабатывается таким же образом, как и запрос <code>create</code> (<em>прим. пер.: в тексте оригинала <code>write</code></em>).
Объекты хранятся со своими отметками времени для уверенности, что при чтении возвращается последняя версия объекта.
Swift также поддерживает функцию контроля версий на поконтейнерной основе.
Если эта опция включена, старые версии объекта также доступны в специальном контейнере под названием <code>versions_container</code>.
</p>

<h4 id="Ch02020304">Один день из жизни операций удаления</h4>
<p>
Запрос <code>delete</code>, отправленный через API вызов HTTP <code>DELETE</code> рассматривается как обновление, но вместо новой версии, размещается версия &quot;надгробной плиты&quot; с нулевыми байтами.
Операция удаления очень сложна в распределенной системе, посколку система будет серьезно бороться с удалением путем воссоздания удаленных копий.
Решение Swift действительно очень элегантное и исключает возможность повторного внезапного появления удаленных объектов.
</p>


<h3 id="Ch020204">Компоненты программного обеспечения заключительной обработки</h3>
<p>
Существует три ключевые программные компоненты завершающей обработки, которые работают в фоновом режиме в отличие от компонент, входящих в информационный канал.
</p>

<h4 id="Ch02020401">Репликации</h4>
<p>
<strong>Репликация</strong> - очень важная сторона Swift.
Репликация гарантирует, что система непротиворечива, то есть, что все серверы и диски, назначенные кольцом для хранения копий объектов или баз данных действительно имеют последнюю версию.
Данный процесс защищает от сбоев, миграции аппаратных средств, а также повторной балансировки кольца (когда кольцо изменяется и данные должны быть перемещены).
Это выполняется  путем сравнения локальных данных судаленными копиями.
Если удаленная копия должна быть обновлена, процесс репликации &quot;выталкивает&quot; копию.
Процесс сравнения довольно эффективен и осуществляется путем простого сравнения хэш- списков, в отличие от байтового сравнения всех объектов (или учетных записей или баз данных контейнеров).
Для копирования данных репликация использует Rsync, утилиту дистанционной синхронизации из Linux, однако существуют планы ее замены на более быстрый механизм.
</p>

<h4 id="Ch02020402">Корректоры</h4>
<p>
При определенных обстоятельствах серверы учетных записей или контейнеров могут быть заняты из-за большой загруженности или недоступности.
В этом случае, обновление ставится в очередь на локальном хранилище сервера хранения.
Существует два <strong>корректора</strong> для обработки этих элементов очереди.
Корректор объектов будет обновлять объекты в базе данных контейнера, в то время как корректор контейнеров будет обновлять контейнеры в базе данных учетных записей.
Такая ситуация может привести к интересным возможным характерам изменения согласованности, при которых объект будет доступен, но список контейнера в то же время не содержит его.
Такие окна несоответствия, как правило, очень малы.
</p>

<h4 id="Ch02020403">Аудиторы</h4>
<p>
<strong>Аудиторы</strong> обходят все объекты, контейнеры и учетные записи для их проверки на целостность данных.
Это выполняется путем вычисления хэша MD5 и его сравнения с сохраненными значениями хешей.
Если определено, что элемент поврежден, тогда он перемещается в каталог карантина, а со временем процесс репликации создаст чистую копию.
Именно так система самовосстанавливается.
MD5-хэш также доступна пользователям, следовательно они могen выполнять такие операции, как сравнение хэш объекта в их местоположении с тем, что хранится в Swift.
</p>

<h4 id="Ch02020404">Другие процессы</h4>
<p>Другие фоновые процессы следующие:
<ul>
 <li><strong>Чистильщик учетных записей</strong> (Account reaper): 
Этот процесс выполняется в фоновом режиме и отвечает за удаление всей учетной записи после того, как она будем помечена для удаления в безе данных.
 <li><strong>Гаситель объектов</strong> (Object expirer):
Swift позволяет пользователям устанавливать политики хранения, обеспечивая  информацию &quot;удалить-d&quot; (delete-at) или &quot;удалить-после&quot; (delete-after) для объектов.
Этот процесс гарантирует, что просроченные объекты удаляются.
 <li><strong>Аудит приводов</strong> (Drive audit):
Это еще один полезный фоновый процесс, который следит за плохими дисками и демонтирует их.
Это может оказаться более эффективным, нежели позволить аудитору разбираться с таким отказом.
 <li><strong>Синхронизация контейнер в контейнер</strong>:
Наконец, при промощи процесса синхронизации контейнера в контейнер, все содержимое контейнера должно отображаться в другой контейнер.
Эти контейнеры могут находиться в различных кластерах и операция использует секретный ключ синхронизации.
До появления поддержки нескольких регионов, эта функция была единственным способом получить несколько копий ваших данных в двух или большем числе регионов, и, таким образом, эта функция является менее важной, чем это было ранее.
Тем не менее, она по-прежнему очень полезна для гибридных (с комбинацией частных и общественных) или облаков сообществ (объединяющих несколько частных облаков).
</ul></p>

<h3 id="Ch020205">Встроенные функции программного обеспечения промежуточного слоя</h3>
<p>
Для расширения функциональных возможностей Swift, в дополнение к упомянутым основным компонентам информационных каналов, в них могут быть размещены другие элементы. 
Это достигается использованием преимуществ архитектуры Swift, которые позволяют вставлять модули промежуточного программного обеспечения.
Ниже приводится неполный список различных модулей промежуточного программного обеспечения.
Большинство из них применяются только к прокси-серверу, однако некоторые модули, такие, как протоколирование (logging) и разведка (recon) применимы также и к другим серверам.
</p>

<h4 id="Ch02020501">Аутентификация</h4>
<p>
Аутентификация является одной из самых важных встроенных функций.
Все промежуточное программное обеспечение Swift является раздельным и используется для расширения Swift; таким образом, системы аутентификации являются отдельными проектами и можно выбрать один из нескольких.
Аутентификация Keystone является официальной службой идентичности OpenStack и может использоваться в сочетании со Swift, хотя нет средств препятствующих возможности создания пользователем собственной системы аутентификации или выполнять аутентификацию с помощью других средств, таких как Swauth или TempAuth.
</p><p>
Аутентификация работает следующим образом:<ol>
 <li>Пользователь предоставляет системt аутентификации необходимые ей данные.
Это делается путем выполнения API вызова HTTP REST.
 <li>Система аутентификации снабжает пользователя маркером AUTH.
 <li>Маркер AUTH неявляется уникальным для каждого запроса, однако его действие истекает по прошествии некоторого времени.
 <li>Каждый сделанный к Swift запрос имеет сопроводительный маркер AUTH. 
 <li>Swift сверяет результат с системой авторизации и кеширует результат.
Результат сбрасывается по окончанию.
 <li>Как правило, система идентификации имеет понятие учетных записей администраторов и учетных записей без прав администраторов.
Очевидно, запросы администратора пропускаются.
 <li>Запросы без прав администраторов проверяются по контейнеру списков управления доступом (<strong>ACL</strong>, <strong>Access Control Lists</strong>).
Эти списки позволяют администратору установить ACL на чтаение и запись для каждого пользователя без прав администратора.
 <li>Таким образом, для пользователей без прав администратора, ACL проверяется перед выполнением запроса прокси-сервером.
На следующем рисунке показаны выполняющиеся этапы, при взаимодействии Swift с системой идентификации:
	<div style="width: 554px; margin: 1.75em auto;">
	<p style="text-align: center;">
		<img src="i/Pic02-05.jpg" alt="Swift и его взаимодействие с системой аутентификации" title="Swift и его взаимодействие с системой аутентификации" width="554" height="332" style="width: 554px" />
		<span class="image-caption">Swift и его взаимодействие с системой аутентификации</span>
	</p></div>
</ol></p>

<h4 id="Ch02020502">Протоколирование</h4>
<p>
Протоколирование очень важный модуль.
Этот компонент обеспечивает ведение журналов.
Пользователь также может вставить свой собственный обработчик журнала.
</p>

<h4 id="Ch02020503">Другие модули</h4>
<p><ul>Также  доступен ряд других модулей промежуточного программного обеспечения Swift и сторонних разработчиков; ниже приведенo несколько примеров:
 <li><strong>Проверка состояния</strong> (Health check):
Этот модуль обеспечивает простой способ мониторинга работает ли прокси-сервер.
Просто получите доступ к прокси-серверу с проверкой path/health и сервер ответит <code>OK</code>.
 <li><strong>Переназначение домена</strong> (Domain remap):
Этот компонент позволяет вам переназначить учетные записи и имя контейнера с пути в имя хоста домена.
Это позволяет упростить доменные имена.
 <li><strong>Поиск CNAME</strong> (CNAME lookup):
Используя это программное обеспечение, вы можете создать дружественные доменные имена, которые перназначаются непосредственно на ваши учетные записи или контейнеры.
Поиск CNAME и переназначение домена могут использоваться совместно.
 <li><strong>Ограничение скорости</strong> (Rate limiting):
Ограничение скорости используется для ограничения скорости запросов, которое имеет результатом записи в базы данных серверов учетных записей и контейнеров.
 <li><strong>Квоты контейнеров и учетных записей</strong> (Container and account quotas):
С помощью этих двух модулей промежуточного программного обеспечения администратор может установить квоты контейнеров или учетных записей.
 <li><strong>Массовое удаление</strong> (Bulk delete):
Этот компонент позволяет массовые операции, таких как удаление нескольких объектов или контейнеров.
 <li><strong>Массовая архивация и автоизвлечение</strong> (Bulk archive auto-extraction):
Используйте это программное обеспечение для выполнения массового извлечения из TAR (TAR, tar.gz, tar.bz2) файлов с помощью одной команды.
 <li><strong>Временный URL</strong> TempURL:
Промежуточное программное обеспечение TempURL позволяет создать URL, который обеспечивает временный доступ к объекту.
Этот доступ не требует аутентификации, однако истекает после определенного периода времени.
Кроме того, доступ осуществляется только к одному объекту, и никакие другие объекты не могут быть доступны через этот URL.
 <li><strong>Сервер начала Swift</strong> (Swift origin server):
Именно этот модуль позволяет использовать Swift как исходный сервер для сети доставки контента (CDN, Content Delivery Network).
 <li><strong>Статический веб-сайт</strong> (Static web):
Это программное обеспечение преобразует Swift в статический веб-сервер.
Вы также можете предоставить стили CSS для получения полного контроля над внешним видом и осязанием ваших страниц.
Очевидно, запросы могут приходить от анонимных источников.
 <li><strong>Form post</strong>:
При использовании промежуточного программного обеспечения Form post, вы получаете возможность загружать объекты Swift с использованием отправки стандартных форм HTML.
Программное обеспечение промежуточного уровня преобразует различные запросы <code>POST</code> в разные запросы <code>PUT</code>, причем запросы не подвергаются аутентификации допуская сотрудничество между пользователями и не-пользователями кластера.
 <li><strong>Recon</strong>:
Recon является программой, полезной для управления.
Она обеспечивает мониторинг и возвращает различные метрики кластера.
</ul></p>

<h2 id="Ch0203">Дополнительная функциональность</h2>
<p>
Swift имеет дополнительные функции, которые не упомянуты в предыдущих разделах.
В последующих разделах детализируются некоторые из дополнительных возможностей.
</p>

<h3 id="Ch020301">Поддержка больших объектов</h3>
<p>
Swift устанавливает ограничение на размер одного загружаемого объекта (по умолчанию 5 ГБ), но позволяет хранить и скачивать объекты практически неограниченного размера.
Используется техника сегментации.
Объект разбивается на сегменты равного размера (за исключением последнего) и загружаются.
Эти загрузки эффективны, поскольку нет одного  неоправданно большого сегмента, а передача данных может быть выполнена параллельно.
После завершения загрузки, загружается файл манифеста, который показывает, как сегменты образуют один большой объект.
Загрузка является одной операцией при которой Swift объединяет различные сегменты воссоздавая один большой объект.
</p>

<h3 id="Ch020302">Метаданные</h3>
<p>
Swift позволяет присоединять полученные в виде пользовательских заголовков пользовательские метаданные к учетным записям, контейнерам или объектам.
Метаданные являются просто парой ключ (имя) - значение.
Метаданные могут быть предоставлены во время создания объекта (с помощью <code>PUT</code>) или обновлены позже (с помощью <code>POST</code>).
Метаданные могут быть получены независимо от объекта с помощью метода <code>HEAD</code>.
</p>

<h3 id="Ch020303">Поддержка мультидиапазонности</h3>
<p>
Спецификация HTTP допускает операции <code>GET</code> с несколкими диапазонами, и Swift позволяет извлекать несколько диапазонов объекта вместо всего объекта.
</p>

<h3 id="Ch020304">CORS</h3>
<p>
CORS является спецификацией, которая позволяет JavaScript работать в браузере, выполняя запрос к доменам, отличным от тех, с которых был взят код.
Swift поддерживает ее, и данная особенность делает возможным для вас, чтобы размещать ваши веб-страницы с JavaScript на одном домене и запрашивать объекты из кластера Swift с другого домена.
Swift также поддерживает более широкий файл междоменной политики, в котором другие технологии стороны клиента, такие как Flash, Java и Silverlight, также могут взаимодействовать со Swift, который расположен в другом домене.
</p>

<h3 id="Ch020305">Копии на стороне сервера</h3>
<p>
Swift позволяет вам сделать копию объекта с помощью различного расположение контейнера и/или названия объекта.
Вся операция копирования выполняется на стороне сервера, таким образом, разгружая клиента.
</p>

<h3 id="Ch020306">Состояние кластера</h3>
<p>
Инструмент под названием swift-dispersion-report может быть использован для измерения общего состояния кластера.
Она делает это путем проверки того, что различные реплики объекта и контейнера находятся на своих местах.
</p>

<h2 id="Ch0204">Заключение</h2>
<p>
Таким образом, Swift принимает набор стандартных серверов и создает надежную и масштабируемую систему хранения данных, которая проста в управлении.
В этой главе мы рассмотрели архитектуру Swift и основные функциональные возможности.
Следующая глава показывает, как можно установить Swift в вашей собственной среде, используя несколько серверов.
</p>


<table width="100%" border="0" cellpadding="2" cellspacing=0 class="bg_White"><tbody><tr>
 <td align="left"><a href="Ch01ru.htm">Глава 1</a></td>
 <td align="center"><a href="ToC.htm">Оглавление</a></td>
 <td align="right"><a href="Ch03ru.htm">Глава 3</a></td>
</tr><tr><td colspan="3" style="border-bottom: thin solid;">&nbsp;</tr>
<tr><td colspan="2" valign="top">Перевод: Copyright ©&nbsp;2014 &nbsp;<img src="/i/mdl-reg.jpg" widht="35" height="12" style="border-style: none;">.<br>
All rights reserved.<br />
Ссылки обязательны (Refs and links obligatory).</td>
<td valign="top" align="right"><em><a href="http://www.mdl.ru">http://www.mdl.ru</a></em></td></tr>
</tbody></table>


<td align="right" valign="top">
<script language="javascript">
WriteABC('GPFS');
//--></script>
</tr>
</tbody></table>
</body>
</html>
