User-facing Operations

This guide is for OpenStack operators and does not seek to be an exhaustive reference for users, but as an operator it is important that you have a basic understanding of how to use the cloud facilities. This chapter looks at OpenStack from a basic user perspective, which helps you understand your usersí needs and determine when you get a trouble ticket whether it is a user issue or a service issue.
 The main concepts covered are images, flavors, security groups, blocks storage and instances.

Images
OpenStack images can often be thought of as &quot;virtual machine templates&quot;.
 Images can
also be standard installation mediums like ISO images. Essentially, they contain bootable file systems which are used to launch instances.

Adding Images
Several pre-made images exist and can easily be imported into the Image Service.
 A common image to add is the CirrOS image which is very small and used for testing purposes.
 To add this image, simply do:
<br /><code>
# wget https://launchpad.net/cirros/trunk/0.3.0/+download/cirros-0.3.0-x86_64-disk.img <br />
# glance image-create --name='cirros image' --is-public=true --container-format=bare --disk-format=qcow2 &lt; cirros-0.3.0-x86_64-disk.img<br />
</code>

The glance <code>image-create</code> command provides a large set of options to give your image.
 For example, the <code>min-disk</code> option is useful for images that require root disks of a certain size (for example, large Windows images). To view these options, do:
<br /><code>
$ glance help image-create<br />
</code>

The  location option is important to note.
 It does not copy the entire image into Glance, but reference an original location to where the image can be found.
 Upon launching an instance of that image, Glance accesses the image from the location specified.

The  <code>copy-from</code> option copies the image from the location specified into the <code>/var/lib/glance/imagesdirectory</code>.
 The same thing is done when using the <code>STDIN</code> redirection such as shown in the example.
 Run the following command to view the properties of existing images:
<br /><code>
$ glance details<br />
</code>

Deleting Images
To delete an image, just execute:
<br /><code>
$ glance image-delete &lt;image uuid&gt;<br />
</code>

Deleting an image does not affect instances or snapshots that were based off the image.

Other CLI Options
A full set of options can be found using:
<br /><code>
$ glance help<br />
</code>

or the  <span class="red-heading">OpenStack Image Service</span> CLI Guide. (http://docs.openstack.org/cli/quickstart/content/glance-cli-reference.html)

The Image Service and the Database
The only thing that Glance does not store in a database is the image itself.
 The Glance database has two main tables:
ï images
ï image_properties
Working directly with the database and SQL queries can provide you with custom lists and reports of Glance images.
 Technically, you can update properties about images through the database, although this is not generally recommended.

Example Image Service Database Queries
One interesting example is modifying the table of images and the owner of that image.
 This can be easily done if you simply display the unique ID of the owner, this example goes one step further and displays the readable name of the owner:
<br /><code>
$ mysql&gt; select glance.images.id, glance.images.name, keystone.tenant.name, is_public from glance.images inner join keystone.tenant on glance.images.owner=keystone.tenant.id;<br />
</code>

Another example is displaying all properties for a certain image:
<br /><code>
$ mysql&gt; select name, value from image_properties where id = &lt;image_id&gt;<br />
</code>


Flavors
Virtual hardware templates are called &quot;flavors&quot; in OpenStack, defining sizes for RAM, disk, number of cores and so on. The default install provides a range of five flavors.
 These are configurable by admin users (this too is configurable and may be delegated by redefining the access controls for <code>compute_extension:flavormanage</code> in  <code>/etc/nova/policy.json</code> on the <code>nova-api</code> server).
 To get a list of available flavors on your system run:
<br /><code>
$ nova flavor-list<br />
+----+-----------+-----------+------+-----------+\+-------+-\+-------------+<br />
| ID | Name &nbsp; &nbsp; &nbsp;| Memory_MB | Disk | Ephemeral |/| VCPUs | /| extra_specs |<br />
+----+-----------+-----------+------+-----------+\+-------+-\+-------------+<br />
| 1 &nbsp;| m1.tiny &nbsp; | 512 &nbsp; &nbsp; &nbsp; | 1 &nbsp; &nbsp;| 0 &nbsp; &nbsp; &nbsp; &nbsp; |/| 1 &nbsp; &nbsp; | /| {} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| 2 &nbsp;| m1.small &nbsp;  2048 &nbsp; &nbsp; &nbsp;| 10 &nbsp; | 20 &nbsp; &nbsp; &nbsp; &nbsp;|\| 1 &nbsp; &nbsp; | \| {} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| 3 &nbsp;| m1.medium | 4096 &nbsp; &nbsp; &nbsp;| 10 &nbsp; | 40 &nbsp; &nbsp; &nbsp; &nbsp;|/| 2 &nbsp; &nbsp; | /| {} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| 4 &nbsp;| m1.large &nbsp;| 8192 &nbsp; &nbsp; &nbsp;| 10 &nbsp; | 80 &nbsp; &nbsp; &nbsp; &nbsp;|\| 4 &nbsp; &nbsp; | \| {} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| 5 &nbsp;| m1.xlarge | 16384 &nbsp; &nbsp; | 10 &nbsp; | 160 &nbsp; &nbsp; &nbsp; |/| 8 &nbsp; &nbsp; | /| {} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
+----+-----------+-----------+------+-----------+\+-------+-\+-------------+<br />
</code>

The <code>nova flavor-create</code> command allows authorized users to create new flavors.
Additional flavor manipulation commands can be shown with the command:
<br /><code>
$ nova help | grep flavor.<br />
</code>

Flavors define a number of elements:

<table width="100%" border="0" cellpadding="2" cellspacing=0 class="bg_White"><tbody><tr>
 <td width="20%"><strong>√‡Ù‡</strong><br />&nbsp;</td>
 <td width="80%"><strong>ŒÔËÒ‡ÌËÂ</strong><br />&nbsp;</td>
</tr><tr><td>
ID<br />&nbsp;</td><td>
 A unique numeric id.<br />&nbsp;</td>
</tr><tr><td>
Name<br />&nbsp;</td><td>
 a descriptive name. xx.size_name is conventional not required, though some third party tools may rely on it.<br />&nbsp;</td>
</tr><tr><td>
Memory_MB<br />&nbsp;</td><td>
 Memory_MB: virtual machine memory in megabytes.<br />&nbsp;</td>
</tr><tr><td>
Disk<br />&nbsp;</td><td>
 Virtual root disk size in gigabytes. This is an ephemeral disk the base image is copied into.
 When booting from a persistent volume it is not used.
 The &quot;0&quot; size is a special case which uses the native base image size as the size of the ephemeral root volume.<br />&nbsp;</td>
</tr><tr><td>
Ephemeral<br />&nbsp;</td><td>
 Specifies the size of a secondary ephemeral data disk.
 This is an empty, unformatted disk and exists only for the life of the instance.<br />&nbsp;</td>
</tr><tr><td>
Swap<br />&nbsp;</td><td>
 Optional swap space allocation for the instance.
 VCPUs Number of virtual CPUs presented to the instance.<br />&nbsp;</td>
</tr><tr><td>
RXTX_Factor<br />&nbsp;</td><td>
 Optional property allows created servers to have a different bandwidth cap than that defined in the network they are attached to.
 This factor is multiplied by the rxtx_base property of the network.
 Default value is 1.0 (that is, the same as attached network).<br />&nbsp;</td>
</tr><tr><td>
Is_Public<br />&nbsp;</td><td>
 Boolean value, whether flavor is available to all users or private to the tenant it was created in.
 Defaults to True.<br />&nbsp;</td>
</tr><tr><td>
extra_specs<br />&nbsp;</td><td>
 Additional optional restrictions on which compute nodes the flavor can run on.
 This is implemented as key/value pairs that must match against the corresponding key/value pairs on compute nodes.
 Can be used to implement things like special resources (such as flavors that can only run on compute nodes with GPU hardware).<br />&nbsp;</td>
</tr></tbody></table>

How do I modify an existing flavor?

Unfortunately, OpenStack does not provide an interface for modifying flavors, only for creating and deleting them. The OpenStack Dashboard simulates the ability to modify a flavor by deleting an existing flavor and creating a new one with the same name.

Security groups
One of the most common new user issues with OpenStack is failing to set appropriate security group when launching an instance and are then unable to contact the instance on the network.
Security groups are sets of IP filter rules that are applied to an instanceís networking.

They are project specific and project members can edit the default rules for their group and add new rules sets.
 All projects have a &quot;default&quot; security group which is applied to instances which have no other security group defined, unless changed this security group denies all incoming traffic.

The <code>nova.conf</code> option <code>allow_same_net_traffic</code> (which defaults to true) globally controls whether the rules applies to hosts which share a network. When set to true, hosts on the same subnet are not filtered and are allowed to pass all types of traffic between them.
 On a flat network, this allows all instances from all projects unfiltered communication.
 With VLAN networking, this allows access between instances within the same project.
 If <code>allow_same_net_trafficis</code> set to false, security groups are enforced for all connections, in this case it is possible for projects to simulate the <code>allow_same_net_traffic</code> by configuring their default security group to allow all traffic from their subnet.

Security groups for the current project can be found on the Horizon dashboard under &quot;Access &amp; Security&quot; to see details of an existing group select the &quot;edit&quot; action for that security group. Obviously modifying existing groups can be done from this &quot;edit&quot; interface.
 There is a &quot;Create Security Group&quot; button on the main Access &amp; Security page for creating new groups.
 We discuss the terms used in these fields when we explain the command line equivalents.

From the command line you can get a list of security groups for the project youíre acting in using the nova command:
<br /><code>
$ nova secgroup-list<br />
+---------+-------------+<br />
| Name &nbsp; &nbsp;| Description |<br />
+---------+-------------+<br />
| default | default &nbsp; &nbsp; |<br />
| open &nbsp; &nbsp;| all ports &nbsp; |<br />
+---------+-------------+<br />
</code>

To view the details of the &quot;open&quot; security group:
<br /><code>
$ nova secgroup-list-rules open<br />
+-------------+-----------+---------+-----------+--------------+ <br />
| IP Protocol | From Port | To Port | IP Range &nbsp;| Source Group | <br />
+-------------+-----------+---------+-----------+--------------+ <br />
| icmp &nbsp; &nbsp; &nbsp; &nbsp;| -1 &nbsp; &nbsp; &nbsp; &nbsp;| 255 &nbsp; &nbsp; | 0.0.0.0/0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />
| tcp &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp; &nbsp; &nbsp; &nbsp; | 65535 &nbsp; | 0.0.0.0/0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />
| udp &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp; &nbsp; &nbsp; &nbsp; | 65535 &nbsp; | 0.0.0.0/0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| <br />
+-------------+-----------+---------+-----------+--------------+ <br />
</code>

These rules are all &quot;allow&quot; type rules as the default is deny.
 The first column is the IP protocol (one of icmp, tcp, or udp) the second and third columns specify the affected port range.
 The third column specifies the IP range in CIDR format.
 This example shows the full port range for all protocols allowed from all IPs.

As noted in the previous chapter the number of rules per security group is controlled by the <code>quota_security_group_rules</code> and the number of allowed security groups per project is controlled by the <code>quota_security_groups</code> quota. 

When adding a new security group you should pick a descriptive but brief name.
 This name shows up in brief descriptions of the instances that use it where the longer description field often does not.
 Seeing that an instance is using security group &quot;http&quot; is much easier to understand than &quot;bobs_group&quot; or &quot;secgrp1&quot;.

As an example, letís create a security group that allows web traffic anywhere on the internet.
 Weíll call this &quot;global_http&quot; which is clear and reasonably concise, encapsulating what is allowed and from where.
 From the command line:
<br /><code>
+-------------+-------------------------------------+<br />
| Name &nbsp; &nbsp; &nbsp; &nbsp;| Description &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />
+-------------+-------------------------------------+<br />
| global_http | allow web traffic from the internet |<br />
+-------------+-------------------------------------+<br />
</code>

This creates the empty security group to make it do what we want we need to add some rules.

<br /><code>
$ nova secgroup-add-rule &lt;secgroup&gt; &lt;ip-proto&gt; &lt;from-port&gt; &lt;to-port&gt; &lt;cidr&gt;<br />
$ nova secgroup-add-rule global_http tcp 80 80 0.0.0.0/0<br />
+-------------+-----------+---------+-----------+--------------+<br />
| IP Protocol | From Port | To Port | IP Range &nbsp;| Source Group |<br />
+-------------+-----------+---------+-----------+--------------+<br />
| tcp &nbsp; &nbsp; &nbsp; &nbsp; | 80 &nbsp; &nbsp; &nbsp; &nbsp;| 80 &nbsp; &nbsp; &nbsp;| 0.0.0.0/0 |              |<br />
+-------------+-----------+---------+-----------+--------------+<br />
</code>


Note that the arguments are positional and the &quot;from-port&quot; and &quot;to-port&quot; arguments specify the local port range connections are allowed to not source and destination ports of the connection.
 More complex rule sets can be built up through multiple invocations of nova secgroup-add-rule.
 For example if you want to pass both http and https traffic:
<br /><code>
$ nova secgroup-add-rule global_http tcp 443 443 0.0.0.0/0<br />
+-------------+-----------+---------+-----------+--------------+<br />
| IP Protocol | From Port | To Port | IP Range &nbsp;| Source Group |<br />
+-------------+-----------+---------+-----------+--------------+<br />
| tcp &nbsp; &nbsp; &nbsp; &nbsp; | 443 &nbsp; &nbsp; &nbsp; | 443 &nbsp; &nbsp; | 0.0.0.0/0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
+-------------+-----------+---------+-----------+--------------+<br />
</code>


Despite only outputting the newly added rule this operation is additive:
<br /><code>
$ nova secgroup-list-rules global_http<br />
+-------------+-----------+---------+-----------+--------------+<br />
| IP Protocol | From Port | To Port | IP Range &nbsp;| Source Group |<br />
+-------------+-----------+---------+-----------+--------------+<br />
| tcp &nbsp; &nbsp; &nbsp; &nbsp; | 80 &nbsp; &nbsp; &nbsp; &nbsp;| 80 &nbsp; &nbsp; &nbsp;| 0.0.0.0/0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| tcp &nbsp; &nbsp; &nbsp; &nbsp; | 443 &nbsp; &nbsp; &nbsp; | 443 &nbsp; &nbsp; | 0.0.0.0/0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
+-------------+-----------+---------+-----------+--------------+<br />
</code>

The inverse operation is called secgroup-delete-rule, using the same format.
 Whole security groups can be removed with secgroup-delete.
To create security group rules for a cluster of instances:
SourceGroups are a special dynamic way of defining the CIDR of allowed sources.
The user specifies a SourceGroup (Security Group name), all the usersí other Instan?
ces using the specified SourceGroup are selected dynamically. This alleviates the need
for a individual rules to allow each new member of the cluster.usage:
usage: nova secgroup-add-group-rule &lt;secgroup&gt; &lt;source-group&gt; &lt;ip-proto&gt; &lt;from-port&gt; &lt;to-port&gt;
<br /><code>
$ nova secgroup-add-group-rule cluster global-http tcp 22 22<br />
</code>

The &quot;cluster&quot; rule allows ssh access from any other instance that uses the &quot;global-http&quot; group.

Block Storage
OpenStack volumes are persistent block storage devices which may be attached and detached from instances, but can only be attached to one instance at a time, similar to an external hard drive they do not proved shared storage in the way a network file system or object store does.
 It is left to the operating system in the instance to put a file system on the block device and mount it, or not.

Similar to other removable disk technology it is important the operating system is not trying to make use of the disk before removing it.
 On Linux instances this typically involves unmounting any file systems mounted from the volume.
 The OpenStack volume service cannot tell if it is safe to remove volumes from an instance so it does what it is told.
 If a user tells the volume service to detach a volume from an instance while it is being written to you can expect some level of file system corruption as well as faults from whatever process within the instance was using the device.

There is nothing OpenStack specific in being aware of the steps needed from with in the instance operating system to access block devices, potentially formatting them for first use and being cautious when removing devices.
 What is specific is how to create new volumes and attach and detach them from instances.
 These operations can all be done from the &quot;Volumes&quot; page of the Dashboard or using the cinder command line client.

To add new volumes you only need a name and a volume size in gigabytes, ether put these into the &quot;create volume&quot; web form or using the command line:
<br /><code>
$ cinder create --display-name test-volume 10<br />
</code>

This creates a 10 GB volume named &quot;test-volume.&quot;
 To list existing volumes and the instances they are connected to if any:
<br /><code>
$ cinder list<br />
+------------+---------+--------------------+------+-------------+-------------+<br />
| ID &nbsp; &nbsp; &nbsp; &nbsp; | Status &nbsp;| Display Name &nbsp; &nbsp; &nbsp; | Size | Volume Type | Attached to |<br />
+------------+---------+--------------------+------+-------------+-------------+<br />
| 0821...19f | active &nbsp;| test-volume &nbsp; &nbsp; &nbsp; &nbsp;| 10 &nbsp; | None &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />
+------------+---------+--------------------+------+-------------+-------------+<br />
</code>

The Block Storage service also allows for creating snapshots of volumes.
 Remember this is a block level snapshot which is crash consistent so it is best if the volume is not connected to an instance when the snapshot is taken and second best if the volume is not in use on the instance it is attached to.
 If the volume is under heavy use, the snapshot may have an inconsistent file system.
 In fact, by default, the volume service does not take a snapshot of a volume that is attached to an image, though it can be forced.
 To take a volume snapshot either select &quot;Create Snapshot&quot; from the actions column next to the volume name in the dashboard volume page, or from the command line:

<br /><code>
usage: cinder snapshot-create [--force &lt;True|False&gt;]<br />
[--display-name &lt;display-name&gt;]<br />
[--display-description &lt;display-description&gt;]<br />
&lt;volume-id&gt;<br />
Add a new snapshot.<br />
Positional arguments: &lt;volume-id&gt; ID of the volume to snapshot<br />
Optional arguments: --force &lt;True|False&gt; Optional flag to indicate whether to <br />
snapshot a volume even if its attached to an instance. <br />
(Default=False) --display-name &lt;display-name&gt; Optional <br />
snapshot name. (Default=None)<br />
--display-description &lt;display-description&gt;<br />
Optional snapshot description. (Default=None)<br />
</code>


Block Storage Creation Failures
If a user tries to create a volume and it immediately goes into an error state, the best way to troubleshoot is to grep the Cinder log files for the volumeís UUID.
 First try the log files on the cloud controller and then try the storage node where they volume was attempted to be created:
<br /><code>
# grep 903b85d0-bacc-4855-a261-10843fc2d65b /var/log/cinder/*.log <br />
</code>

Instances
Instances are the running virtual machines within an OpenStack cloud.
 This section deals with how to work with them and their underlying images, their network properties and how they are represented in the database.

Starting Instances

To launch an instance you need to select an image, a flavor, and a name.
 The name neednít be unique but your life is simpler if it is because many tools will use the name in place of UUID so long as the name is unique.
 This can be done from the dash? board either from the &quot;Launch Instance&quot; button on the &quot;Instances&quot; page or by selecting the &quot;Launch&quot; action next to an image or snapshot on the &quot;Images &amp; Snapshots&quot; page.

On the command line:
<br /><code>
$ nova boot --flavor &lt;flavor&gt; --image &lt;image&gt; &lt;name&gt;<br />
</code>


There are a number of optional items that can be specified. You should read the rest of this instances section before trying to start one, but this is the base command that later details are layered upon.

To delete instances from the dashboard select the &quot;Terminate instance&quot; action next to the instance on the &quot;Instances&quot; page, from the command line:
<br /><code>
$ nova delete &lt;instance-uuid&gt;<br />
</code>


It is important to note that powering off an instance does not terminate it in the OpenStack sense.

Instance Boot Failures
If an instance fails to start and immediately moves to &quot;Error&quot; state there are a few different ways to track down what has gone wrong.
 Some of these can be done with normal user access while others require access to your log server or compute nodes.

The simplest reasons for nodes to fail to launch are quota violations or the scheduler being unable to find a suitable compute node on which to run the instance.
 In these cases the error is apparent doing a nova showon the faulted instance.
<br /><code>
$ nova show test-instance<br />
+------------------------+-----------------------------------------------------\<br />
| Property &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /<br />
+------------------------+-----------------------------------------------------\<br />
| OS-DCF:diskConfig &nbsp; &nbsp; &nbsp;| MANUAL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/<br />
| OS-EXT-STS:power_state | 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br />
| OS-EXT-STS:task_state &nbsp;| None &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/<br />
| OS-EXT-STS:vm_state &nbsp; &nbsp;| error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;\<br />
| accessIPv4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;/<br />
| accessIPv6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;\<br />
| config_drive &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;/<br />
| created &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2013-03-01T19:28:24Z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br />
| fault &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| {u'message': u'NoValidHost', u'code': 500, u'created/<br />
| flavor &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;| xxl.super (11) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br />
| hostId &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;/<br />
| id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   | 940f3b2f-bd74-45ad-bee7-eb0a7318aa84 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\<br />
| image &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| quantal-test (65b4f432-7375-42b6-a9b8-7f654a1e676e) /<br />
| key_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | None &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\<br />
| metadata &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | {} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; /<br />
| name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | test-instance &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br />
| security_groups &nbsp; &nbsp; &nbsp; &nbsp;| [{u'name': u'default'}] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;/<br />
| status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | ERROR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;\<br />
| tenant_id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 98333a1a28e746fa8c629c83a818ad57 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; /<br />
| updated &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2013-03-01T19:28:26Z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \<br />
| user_id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| a1ef823458d24a68955fec6f3d390019 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; /<br />
+------------------------+-----------------------------------------------------\<br />
</code>

In this case looking at the &quot;fault&quot; message shows NoValidHost indicating the scheduler was unable to match the instance requirements.

If nova show does not sufficiently explain the failure searching for the instance UUID in the <code>nova-compute.log</code> on the compute node it was scheduled on or the <code>novascheduler.log</code> on your scheduler hosts is a good place to start looking for lower level problems.

Using  nova showas an admin user will show the compute node the instance was scheduled on as <code>hostId</code>, if the instance failed during scheduling this field is blank.

Instance-specific Data
There are a variety of ways to inject custom data including authorized_keys key injection, user-data, metadata service, and file injection.

To clarify user-data versus metadata, understand that &quot;user-data&quot; is a chunk of data, set when an instance is not running.
 This user-data is accessible from within the instance when it is running.
 People use this user-data to store configuration, a script, or anything the tenant wants.

For Compute, instance metadata is a collection of key/value pairs associated with an instance.
 Compute reads and writes to these key/value pairs any time during the instance lifetime, from inside and outside the instance, when the end-user uses the

Compute API to do so.
 However, you cannot query the instance associated key/value pairs via the metadata service that is compatible with the Amazon EC2 metadata service.

Users can generate and register ssh keys using the nova command
<br /><code>
$ nova keypair-add mykey &gt; mykey.pem<br />
</code>


This creates a key named mykey which you can associate with instances.
 The file <code>mykey.pem</code> is the private key which should be saved to a secure location as it allows root access to instances the mykey key is associated with.

You can register an existing public key with OpenStack using this command
<br /><code>
$ nova keypair-add --pub-key mykey.pub mykey<br />
</code>

You must have the matching private key to access instances associated with this key.

To associate a key with an instance on boot add <code>--key_name mykey</code> to your command line for example:
<br /><code>
$ nova boot --image ubuntu-cloudimage --flavor 1 --key_name mykey<br />
</code>

When booting a server, you can also add metadata, so that you can more easily identify it amongst other running instances.
 Use the <code>--meta</code> option with a key=value pair, where you can make up the string for both the key and the value.
 For example, you could add a description and also the creator of the server.
<br /><code>
$ nova boot --image=test-image --flavor=1 smallimage --meta description='Small test image'<br />
</code>

When viewing the server information, you can see the metadata included on the metadata line:
<br /><code>
$ nova show smallimage<br />
+------------------------+-----------------------------------------+<br />
| Property &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;| Value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;|<br />
+------------------------+-----------------------------------------+<br />
| OS-DCF:diskConfig &nbsp; &nbsp; &nbsp;| MANUAL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| OS-EXT-STS:power_state | 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;|<br />
| OS-EXT-STS:task_state &nbsp;| None &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| OS-EXT-STS:vm_state &nbsp; &nbsp;| active &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| accessIPv4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />
| accessIPv6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />
| config_drive &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />
| created &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2012-05-16T20:48:23Z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| flavor &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | m1.small &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| hostId &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | de0...487 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;|<br />
| id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 8ec...f915 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| image &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| natty-image &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />
| key_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />
| metadata &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;| {u'description': u'Small test image'} &nbsp; |<br />
| name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;| smallimage2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />
| private network &nbsp; &nbsp; &nbsp; &nbsp;| 172.16.101.11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;|<br />
| progress &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;| 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;|<br />
| public network &nbsp; &nbsp; &nbsp; &nbsp; | 10.4.113.11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br />
| status &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | ACTIVE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| tenant_id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| e83...482 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;|<br />
| updated &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2012-05-16T20:48:35Z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />
| user_id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| de3...0a9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;|<br />
+------------------------+-----------------------------------------+<br />
</code>


User Data is a special key in the metadata service which holds a file that cloud aware applications within the guest instance can access.
 For example <span class="red-heading">cloudinit</span> (https://help.ubuntu.com/community/CloudInit) is an open source package from Ubuntu that handles early initialization of a cloud instance that makes use of this user data.

This user-data can be put in a file on your local system and then passed in at instance creation with the flag --user-data &lt;user-data-file&gt; for example:
<br /><code>
$ nova boot --image ubuntu-cloudimage --flavor 1 --user-data mydata.file <br />
</code>


Arbitrary local files can also be placed into the instance file system at creation time using the <code>--file &lt;dst-path=src-path&gt;</code> option.
 You may store up to 5 files.
 For example if you have a special <code>authorized_keys</code> file named <code>special_authorized_keys</code> file that you want to put on the instance rather than using the regular ssh key injection for some reason you can use the following command:
<br /><code>
$nova boot --image ubuntu-cloudimage --flavor 1 --file /root/.ssh/authorized_keys=special_authorized_keysfile<br />
</code>

Associating Security Groups
Security groups as discussed earlier are typically required to allow network traffic to an instance, unless the default security group for a project has been modified to be more permissive.

Adding security groups is typically done on instance boot. When launching from the dashboard this is on the &quot;Access &amp; Security&quot; tab of the &quot;Launch Instance&quot; dialog.
 When launching from the command line append <code>--security-groups</code> with a comma separated list of security groups.

It is also possible to add and remove security groups when an instance is running.
Currently this is only available through the command line tools.
<br /><code>
$ nova add-secgroup &t;server&gt; &lt;securitygroup&gt;<br />
$ nova remove-secgroup &lt;server&gt; &lt;securitygroup&gt;<br /></code>

Floating IPs

Projects have a quota controlled number of Floating IPs, however these need to be allocated by a user before they are available for use.
 To allocate a Floating IP to a project there is an &quot;Allocate IP to Project&quot; button on the &quot;Access &amp; Security&quot; page of the dashboard or on the command line by using:
<br /><code>
$ nova floating-ip-create<br />
</code>

Once allocated, Floating IP can be assigned to running instances from the Dashboard either by selecting the &quot;Associate Floating IP&quot; from the actions drop down next to the IP on the &quot;Access &amp; Security&quot; page or the same action next to the instance you wish to associate it with on the &quot;Instances&quot; page.
 The inverse action, &quot;Dissociate Floating IP&quot;, is only available from the &quot;Access &amp; Security&quot; page and not from the Instances page.

From the command line, enter the following command to complete these tasks:
<br /><code>
$ nova add-floating-ip &lt;server&gt; &lt;address&gt;<br />
$ nova remove-floating-ip &lt;server&gt; &lt;address&gt;<br />
</code>

Attaching Block Storage
You can attach block storage to instances from the dashboard on the  Volumes  page.
Click the Edit Attachments action next to the volume you wish to attach.

To perform this action from command line, run the following command:
<br /><code>
$ nova volume-attach &lt;server&gt; &lt;volume&gt; <br />
</code>

You can also specify block device mapping at instance boot time through the nova command-line client, as follows:
<br /><code>
--block-device-mapping &lt;dev-name=mapping&gt; <br />
</code>

The block device mapping format is <code>&lt;dev-name=&lt;id&gt;:&lt;type&gt;:&lt;size(GB)&gt;:&lt;deleteon-terminate&gt;</code>, where:

<em>dev-name</em>
 A device name where the volume is attached in the system at <code>/dev/dev_name</code>.

<em>id</em>
 The ID of the volume to boot from, as shown in the output of nova volume-list.

<em>type</em>
 Either  snap, which means that the volume was created from a snapshot, or anything other than  snap(a blank string is valid).
 In the example above, the volume was not created from a snapshot, so we leave this field blank in our example below.

<em>size (GB)</em>
 The size of the volume, in GB.
 It is safe to leave this blank and have the Compute service infer the size.

<em>delete-on-terminate</em>
 A boolean to indicate whether the volume should be deleted when the instance is terminated.
 True can be specified as  True or 1.
 False can be specified as  False or 0.

If you have previously prepared the block storage with a bootable file system image it is even possible to boot from persistent block storage.
 The following example will attempt boot from volume with ID=13, it does not delete on terminate.
 Replace the <code>--key-namewith</code> a valid keypair name:
<br /><code>
$nova boot --flavor 2 --key-name mykey --block-device-mapping vda=13:::0 bootfrom-vol-test<br />
</code>

Because of bug <span class="red-heading">1163566</span> (<a href="https://bugs.launchpad.net/nova/+bug/1163566">https://bugs.launchpad.net/nova/+bug/1163566</a>) you must specify an image when booting from a volume in Horizon, even though this image is not used.

To boot normally from an image and attach block storage, map to a device other than vda.

Taking Snapshots
OpenStackís snapshot mechanism allows you to create new images from running instances.
 This is a very convenient for upgrading base images or taking a published image and customizing for local use.
 To snapshot a running instance to an image using the CLI:
<br /><code>
$ nova image-create &lt;instance name or uuid&gt; &lt;name of new image&gt;<br />
</code>

The Dashboard interface for snapshots can be confusing because the Images &amp; Snapshots page splits content up into:

ï Images
ï Instance snapshots
ï Volume snapshots
However, an instance snapshot is an image.
 The only difference between an image that you upload directly to glance and an image you create by snapshot is that an image created by snapshot has additional properties in the glance database.
 These properties are found in the image_properties table, and include:

<table width="100%" border="0" cellpadding="2" cellspacing=0 class="bg_White"><tbody><tr>
 <td width="20%"><strong>Õ‡Á‚‡ÌËÂ</strong><br />&nbsp;</td>
 <td width="80%"><strong>«Ì‡˜ÂÌËÂ</strong><br />&nbsp;</td>
</tr><tr><td>
image_type<br />&nbsp;</td><td>
 snapshot<br />&nbsp;</td>
</tr><tr><td>
instance_uuid<br />&nbsp;</td><td>
 &lt;uuid of instance that was snapshotted&gt;<br />&nbsp;</td>
</tr><tr><td>
base_image_ref<br />&nbsp;</td><td>
 &lt;uuid of original image of instance that was snapshotted&gt;<br />&nbsp;</td>
</tr><tr><td>
image_location<br />&nbsp;</td><td>
 snapshot<br />&nbsp;</td>
</tr></tbody></table><hr />

Ensuring snapshots are consistent
Content from Sebastien Hanís <span class="red-heading">OpenStack: Perform Consistent Snapshots</span> blog entry (<a href="http://www.sebastien-han.fr/blog/2012/12/10/openstack-perform-consistentsnapshots/">http://www.sebastien-han.fr/blog/2012/12/10/openstack-perform-consistentsnapshots/</a>)

A snapshot captures the state of the file system, but not the state of the memory.
Therefore, to ensure your snapshot contains the data that you want, before your snapshot you need to ensure that:
ï Running programs have written their contents to disk
ï The file system does not have any &quot;dirty&quot; buffers: where programs have issued the command to write to disk, but the operating system has not yet done the write

To ensure that important services have written their contents to disk (such as, databases), we recommend you read the documentation for those applications to determine what commands to issue to have them sync their contents to disk.
 If you are unsure how to do this, the safest approach is to simply stop these running services normally.

To deal with the &quot;dirty&quot; buffer issue, we recommend using the sync command before snapshotting:
<br /><code>
# sync<br />
</code>

Running <code>sync</code> writes dirty buffer (buffered block that have been modified but not written yet to the disk block) to disk.

Just running <code>sync</code> is not enough to ensure the file system is consistent.
 We recommend you use the <code>fsfreeze</code> tool, which halts new access to the file system and create a stable image on disk that is suitable for snapshotting.
 <code>fsfreeze</code> supports several file systems, including <code>ext3</code>, <code>ext4</code>, and <code>XFS</code>.
 If your virtual machine instance is running on Ubuntu, install the util-linux package to get fsfreeze:
<br /><code>
# apt-get install util-linux<br />
</code>

If your operating system doesnít have a version of <code>fsfreeze</code> available, you can use <code>xfs_freeze</code> instead, which is available on Ubuntu in the <code>xfsprogs</code> package.
 Despite the &quot;<code>xfs</code>&quot; in the name, <code>xfs_freeze</code> also works on <code>ext3</code> and <code>ext4</code> if you are using a Linux kernel version 2.6.29 or greater, since it works at the virtual file system (VFS) level starting at 2.6.29.
 <code>xfs_freeze</code> supports the same command-line arguments as <code>fsfreeze</code>.

Consider the example where you want to take a snapshot of a persistent block storage volume, detected by the guest operating system as <code>/dev/vdb</code> and mounted on <code>/mnt</code>.

The <code>fsfreeze</code> command accepts 2 arguments:
ï <code>-f</code>: freeze the system
ï <code>-u</code>: thaw (un-freeze) the system

To freeze the volume in preparation for snapshotting, you would do, as root, inside of the instance:
<br /><code>
# fsfreeze -f /mnt<br />
</code>

You must mount the file system before you run the <em>fsfreeze</em> command.

When the &quot;<code>fsfreeze -f</code>&quot; command is issued, all ongoing transactions in the file system are allowed to complete, new write system calls are halted, and other calls which modify the file system are halted. Most importantly, all dirty data, metadata, and log information are written to disk.

Once the volume has been frozen, do not attempt to read from or write to the volume, as these operations hang.
 The operating system stops every I/O operation and any I/O attempts is delayed until the file system has been unfrozen.

Once you have issued the fsfreeze command, it is safe to perform the snapshot.
 For example, if your instance was named mon-instance, and you wanted to snapshot it to an image, named mon-snapshot, you could now run the following:
<br /><code>
$ nova image-create mon-instance mon-snapshot<br />
</code>

When the snapshot is done, you can thaw the file system with the following command, as root, inside of the instance:
<br /><code>
# fsfreeze -u /mnt<br />
</code>

If you want to backup the root file system, you canít simply do the command above because it will freeze the prompt. Instead, run the following one-liner, as root, inside of the instance:
<br /><code>
# fsfreeze -f / &amp;&amp; sleep 30 &amp;&amp; fsfreeze -u /<br />
</code>

Instances in the Database
While instance information is stored in a number of database tables, the table operators are most likely to need to look at in relation to user instances is the &quot;instances&quot; table.

The instances table carries all most of the information related to both running and deleted instances.
 It has a bewildering array of fields, for an exhaustive list look at the database.
 These are the most useful fields for operators looking to form queries.

The &quot;deleted&quot; field is set to &quot;1&quot; if the instance has been deleted and NULL if it has not been deleted this important for excluding deleted instances from your queries.

The &quot;uuid&quot; field is the UUID of the instance and is used through out other tables in the database as a foreign key.
 This id is also reported in logs, the dashboard and command line tools to uniquely identify an instance.

A collection of foreign keys are available to find relations to the instance.
 The most useful of these are &quot;user_id&quot; and &quot;project_id&quot; are the UUIDs of the user who launched the instance and the project it was launched in.

The &quot;host&quot; field tells which compute node is hosting the instance.

The &quot;hostname&quot; field holds the name of the instance when it is launched.
 The &quot;display-name&quot; is initially the same as hostname but can be reset using the nova rename command.

A number of time related fields are useful for tracking when state changes happened on an instance:
ï created_at
ï updated_at
ï deleted_at
ï scheduled_at
ï launched_at
ï terminated_at
