<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:exsl="http://exslt.org/common" xmlns:ng="http://docbook.org/docbook-ng" xmlns:fb="http://ogp.me/ns/fb#">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="https://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet"/>
<title>Глава 1. Что и почему контейнеров - Использование Docker</title>
<meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/>
<meta name="mavenGroupId" content="www.mdl.ru"/>
<meta name="mavenArtifactId" content="UsingDocker"/>
<meta name="mavenVersionId" content="1.0.0"/>
<link rel="home" href="index.html" title="Использование Docker"/>
<link rel="up" href="index.html" title="Использование Docker"/>
<link rel="prev" href="index.html" title="Вводная часть"/>
<link rel="next" href="Ch02.html" title="Глава 2. Docker одним взглядом"/>
<meta name="git-sha" content=""/>
<meta name="buildTime" content=""/>
<script type="text/javascript">
            //The id for tree cookie
            var treeCookieId = "treeview-using-docker";
            var language = "en";
            var w = new Object();
            //Localization
            txt_filesfound = 'Results';
            txt_enter_at_least_1_char = "You must enter at least one character.";
            txt_browser_not_supported = "Please enable JavaScript.";
            txt_please_wait = "Please wait. Search in progress...";
            txt_results_for = "Results for: ";
</script>
<style type="text/css">
            input {
            margin-bottom: 5px;
            margin-top: 2px;
            }

            .folder {
            display: block;
            height: 22px;
            padding-left: 20px;
            background: transparent url(../common/jquery/treeview/images/folder.gif) 0 0px no-repeat;
            }
</style>
<link rel="shortcut icon" href="../MdlLogo.gif" type="image/gif"/>
<link rel="stylesheet" type="text/css" href="../common/css/positioning.css"/>
<link rel="stylesheet" type="text/css" href="../common/css/custom.css"/>
<link rel="canonical" href="http://onreader.mdl.ru/UsingDocker/content/index.html"/>
<!--[if IE]>
	<link rel="stylesheet" type="text/css" href="../common/css/ie.css"/>
<![endif]-->
<link rel="stylesheet" type="text/css" href="../common/jquery/theme-redmond/jquery-ui-1.8.2.custom.css"/>
<link rel="stylesheet" type="text/css" href="../common/jquery/treeview/jquery.treeview.css"/>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.11.0.min.js"><!----></script>
<script type="text/javascript" src="../common/jquery/jquery-ui-1.8.2.custom.min.js"><!----></script>
<script type="text/javascript" src="../common/jquery/jquery.cookie.js"><!----></script>
<script type="text/javascript" src="../common/jquery/treeview/jquery.treeview.min.js"><!----></script>
<link rel="stylesheet" type="text/css" href="http://cdn.jsdelivr.net/qtip2/2.2.0/jquery.qtip.min.css"/>
<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.js">
<!--jQuery plugin for glossary popups. --></script><script type="text/javascript" src="search/htmlFileList.js"><!----></script>
<script type="text/javascript" src="search/htmlFileInfoList.js"><!----></script>
<script type="text/javascript" src="search/nwSearchFnt.js"><!----></script>
<script type="text/javascript" src="search/stemmers/en_stemmer.js">
<!--//make this scalable to other languages as well.--></script>
<script type="text/javascript" src="search/index-1.js"><!----></script>
<script type="text/javascript" src="search/index-2.js"><!----></script>
<script type="text/javascript" src="search/index-3.js"><!----></script>
<script type="text/javascript">
	    var _gaq = _gaq || [];
	    _gaq.push(['_setAccount', 'UA-17511903-1']);
	    
	    _gaq.push(['_setDomainName', '.openstack.org']);	        
</script>
<script type="text/javascript" src="../common/ga.js"><!----></script>
<script language="javascript" src="/js/common.js"></script>
<link rel="stylesheet" href="../common/css/googlecode.css">
<script src="../common/highlight.pack.js"></script>
</head>
<body>
<!----><script type="text/javascript"><!--
hljs.initHighlightingOnLoad();
HeaderName = 'Глава 1. Что и почему контейнеров';
PrevRef = 'index.html';
UpRef = 'index.html';
NextRef = 'Ch02.html';//-->
</script>
<!----><script type="text/javascript" src="HeaderAndToolbar.js">
</script><script type="text/javascript"><!--
document.write(HeaderAndToolbar); //-->
</script>
<div id="content">
 <div class="part">
  <div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title">
   Часть 1. Предпосылки и основы</h1>
  </div></div></div>
  <p></p>
  <div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title">
   Глава 1. Что и почему контейнеров</h1>
  </div></div></div>

  <div class="toc"><p><strong>Содержание</strong></p>
   <dl>
   <dt><span class="chapter"><a href="Ch01.html">1. Что и почему контейнеров</a></span></dt>
   <dd><dl>
	 <dt><span class="section"><a href="Ch01.html#01.1">Контейнеры против виртуальных машин</a></span></dt>
	 <dt><span class="section"><a href="Ch01.html#01.2">Docker и контейнеры</a></span></dt>
	 <dt><span class="section"><a href="Ch01.html#01.3">Docker: история</a></span></dt>
	 <dt><span class="section"><a href="Ch01.html#01.4">Плагины и сантехника</a></span></dt>
	 <dt><span class="section"><a href="Ch01.html#01.5">Linux 64-бита</a></span></dt>
   </dl></dd>
   </dl>
  </div>
  <p>Контейнеры фундаментально изменяют способ разработки, распространения и выполнения программного обеспечения. Разработчики могут строить 
  программное обеспечение локально, зная что оно будет работать идентично безотносительно от окружения хоста - будь то стойка в ИТ подразделении, 
  пользовательский ноутбук или кластер в облаке. Эксплуатирующий персонал может сосредоточиться на сетевой среде, ресурсах, а также времени 
  работы и тратить меньше времени на настройку окружений и баталии с зависимостями от системы. Применение и понимание контейнеров возрастает 
  с феноменальной скоростью во всей индустрии, начиная с небольших стартапов, вплоть до предприятий больших масштабов. Следует ожидать 
  применение контейнеров разработчиками и сопровождающим персоналом в том или ином виде в последующие несколько лет.</p>
  <p>Контейнеры являются инкапсуляцией приложений вместе с их зависимостями. На первый взгляд они возникли для простой формы виртуальных 
  машин (ВМ) - как и ВМ, контейнеры содержат изолированные экземпляры операционной системы (ОС), которые могут применяться для выполнения 
  приложений.</p>
  <p>Однако контейнеры имеют определённые преимущества, которые делают возможными варианты применения, которые сложны или даже 
  невозможны для ВМ:</p>
  	<div class="itemizedlist">
	<ul class="itemizedlist" type="disc">
	 <li class="listitem">
	 <p>Контейнеры используют ресурсы совместно с операционной системой хоста, что делает их более эффективными на порядок величины. 
	 Контейнеры могут запускаться и останавливаться за доли секунды. Выполняемые в контейнерах приложения несут меньше накладных 
	 расходов по сравнению с работающих обычным образом в операционной системе хоста приложениями.</p>
	 </li>
	 <li class="listitem">
	 <p>Переносимсоть контейнеров имеет потенциал исключить целый класс дефектов программ, вызываемых хитроумными изменениями в 
	 среде выполнения - они могут даже положить конец разработчиками старой закалки постоянно повторяющих &quot;но это работает 
	 на моей машине!&quot;</p>
	 </li>
	 <li class="listitem">
	 <p>Легковесная природа контейнеров означает,что разработчики могут выполнять десятки контейнеров одновременно, делая возможной 
	 эмуляцию распределенной системы промышленного уровня. Обслуживающий персонал может выполнять на одной машине хоста намного больше 
	 контейнеров в сравнении с числом применяемых на ней ВМ.</p>
	 </li>
	 <li class="listitem">
	 <p>Контейнеры также имеют преимущества для конечных пользователей и разработчиков за пределами инсталляции рассматриваемого 
	 облака. Пользователи могут загружать и выполнять сложные приложения без необходимости затрат часов на настройку и установку 
	 выпусков или беспокоиться о необходимых изменениях в системе. Наоборот, разработчики подобных приложений могут перестать 
	 беспокоиться о разнице пользовательских окружений и доступности зависимостей.</p>
	 </li>
    </ul>
    </div>
  <p>Что ещё более важно, фундаментальные цели ВМ и контейнеров являются различными - цель ВИ состоит в в полной эмуляции внешней 
  среды, в то время как цель контейнера состоит в создании переносимого приложения и самодостаточности.</p>
  <p></p>
  <div class="section">
   <div xmlns="" class="titlepage"><div><div>
    <h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="01.1"> </a>Контейнеры против виртуальных машин</h3>
   </div></div></div>
   <p>Хотя контейнеры и ВМ вначале и выглядят очень похожее в начале, существуют некоторые важные различия, которые легче объяснить с 
   применением диаграмм.</p>
   <p><a class="link" href="#Fig0101" target="_top">Рисунок 1-1</a> показывает три приложения, работающие в различных ВМ на хосте. 
   Для создания ВМ и их работы, управления доступом к лежащем в основе ОС и оборудованию, а также для интерпретации по мере необходимости системных 
   вызовов требуется гипервизор (Рисунок изображает гипервизор <span class="emphasis"><em>2 типа</em></span>, например Virtualbox или 
   VMWare Workstation, которые работают поверх ОС хоста; гипервизор <span class="emphasis"><em>1 типа</em></span>, например Xen также 
   возможен, в этом случае гипервизор работает поверх голого железа). Каждой ВМ требуется полная копия ОС, запускаемое приложение и все 
   библиотеки поддержки.</p>
   <div class="figure"><a id="Fig0101"> </a>
    <p class="title"><strong>Рисунок 1.1. Три ВМ, работающие на одном хосте</strong></p>
    <div class="figure-contents"><div class="mediaobject">
     <img src="figures/Fig0101.jpg" width="192" height="365"/><br />
     <span></span>
    </div></div>
   </div><br class="figure-break"/>
   <div class="figure"><a id="Fig0102"> </a>
    <p class="title"><strong>Рисунок 1.2. Три контейнера, работающих на одном хосте</strong></p>
    <div class="figure-contents"><div class="mediaobject">
     <img src="figures/Fig0102.jpg" width="184" height="301"/><br />
     <span></span>
    </div></div>
   </div><br class="figure-break"/>
   <p>В противовес этому <a class="link" href="#Fig0102" target="_top">Рисунок 1-2</a> показывает как те же самые три приложения могут быть 
   запущены в системе с контейнерами. В отличие от ВМ, ядро хоста (ядро является сердцевиной ОС и отвечает за поддержку приложений основными
   системными функциями относящимися к оперативной памяти, процессору и доступу к устройствам; вся ОС состоит из ядра плюс различных системных 
   программ, таких как инициализация систем, компиляторы и оконные менеджеры) совместно используется работающими контейнерами. Это означает, 
   что контейнеры всегда ограничены выполнением одного и того же ядра в качестве хоста. Приложения Y и Z используют те же самые библиотеки и 
   могут совместно использовать эти данные или даже иметь избыточные копии. Движок контейнера отвечает за запуск и остановку контейнеров
   аналогично гипервизору в случае ВМ. Однако, выполняемые внутри контейнеров процессы эквивалентны обычным процессам в хосте и не 
   несут дополнительных накладных расходов связанных с выполнением гипервизора.</p>
   <p>И ВМ, и контейнеры могут применяться для изоляции приложений от прочих приложений, работающих на том же самом хосте. ВМ имеют 
   некую дополнительную изоляцию от гипервизора и являются надежной и закаленной в боях технологией. По этой причине зачастую можно 
   встречаться с гибридными системами, в которых контейнеры запускаются внутри ВМ, чтобы использовать преимущества обеих технологий.</p>
  </div>
  <div class="section">
   <div xmlns="" class="titlepage"><div><div>
    <h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="01.2"> </a>Docker и контейнеры</h3>
   </div></div></div>
   <p>Контейнеры являются старой концепцией. На протяжении десятилетий системы UNIX имели команду <span class="term"><code>chroot</code></span>, 
   которая предоставляла простейшую форму изоляции файловой системы. Начиная с 1998 года FreeBSD обзавелась утилитой 
   <span class="term"><code>jail</code></span>, которая расширила песочницу <span class="term"><code>chroot</code></span> до процессов. 
   Solaris Zone предложили относительно завершенную технологию котейеризации примерно в 2001, однако были ограничены ОС Solaris. Также в 2001, 
   Paralls Inc (позже SWsoft) реализовали коммерческую контейнерную технологию Virtuozzo для Linux, а позже технологию ядра с открытым исходным 
   кодом под названием OpenVZ в 2005 (OpenVZ так и не нашла массового принятия, возможно из-за требования выполнения ядра с доработками). 
   Затем Google запустил разработку CGroup для ядра Linux и начал перемещать свою инфраструктуру на контейнеры. Проект контейнеров Linux (LXC, 
   Linux Container) стартовал в 2008 и свёл воедино CGroup, пространства имён ядра, а также технологию chroot (помимо всего прочего) для 
   обеспечения полностью конейеризованного решения. Наконец, в 2013, Docker внесла последний штрих в паззл контейеризации и эта технология 
   начала входить в мейнстрим.</p>
   <p>Docker взял существующую технологий контейнеров Linux и упаковал и расширил ее различными способами - главным образом благодаря переносимым 
   образам и дружественному для пользователя интерфейсу - создав полное решение для создания и распространения контейнеров. Платформа Docker 
   имеет два различных компонента: движок Docker (Docker Engine), который отвечает за создание и работу контейнеров и хаб Docker (Docker Hub), 
   облачную службу для распространения контейнеров.</p>
   <p>Docker Engine предоставляет быстрый и удобный интерфейс выполнения контейнеров. Раньше выполнение контейнеров использовало технологии 
   подобные LXC, требующие значительных специальных знаний и ручной работы. Docker Hub предоставляет значительное число общедоступных 
   образов контейнеров для загрузки, позволяя пользователям быстро получать запуск и избегать дублирования уже выполненной другими работы. 
   Другие разработанные Docker инструменты включают в себя систему управления кластером <span class="emphasis"><em>Swarm</em></span>; 
   графический интерфейс для работы с контейнерами <span class="emphasis"><em>Kitematic</em></span>; и утилиту командной строки сопровождения 
   хостов Docker <span class="emphasis"><em>Machine</em></span>.</p>
   <p>Открыв исходный код Docker Engine, Docker смог увеличить большое сообщество вокруг Docker и получить преимущества общественной помощи 
   с окружениями и фиксацией ошибок. Быстрый рост Docker означает, что он практически становится стандартом <span class="emphasis"><em>де 
   факто</em></span>, который побуждает индустрию оказывать давление на продвижение разработки независимых формальных стандартов для 
   исполнения контейнеров и их формата. В 2015г это нашло свою кульминацию в учреждении открытой инициативы контейнеров (Open Container Initiative), 
   &quot;управляющей структуры&quot; спонсируемой Docker, Microsoft, CoreOS и многими прочими важными организациями, чья миссия состоит в 
   разработке подобного стандарта. В основе их усилий лежат формат контейнера Docker и его формы исполнения.</p>
   <p>Поглощение контейнеров быстро продвигалось разработчиками, которым на первое время были предоставлены инструменты для эффективного 
   применения контейнеров. Быстрое время запуска контейнеров важно разработчикам, которые жаждут быстрых и повторяемых циклов в которых 
   они могут сразу увидеть результаты изменений кода. Переносимость и изолирование гарантируют контейнерам легкое сотрудничество с другими 
   разработчиками и эксплутационщиками; разработчики могут быть уверены что их код будет работать по всем средам, а сопровождающий персонал 
   может сфокусироваться на хостинге и оркестровке контейнеров вместо беспокойств о коде работающем внутри них.</p>
   <p>Привнесенные Docker изменения существенно изменили способ, которым мы разрабатываем программное обеспечение. Без Docker контейнеры 
   ещё долго бы оставались в тени информационных технологий в течение продолжительного времени в будущем.</p>
   <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Замечание"><tr><td rowspan="2" align="center" valign="top" width="25"><a id="ShippingMetaphor"> </a>
	 <img alt="[Замечание]" src="../common/images/admon/note.png"/></td><th align="left">Перевозочная метафора</th></tr><tr><td align="left" valign="top">
	 <p>Философия Docker часто объясняется в терминах метафоры транспортного контейнера, которая по-видимому объясняет имя Docker. История 
	 обычно рассказывается как-то так:</p>
	 <p>При транспортировке товаров они должны пройти через различные <span class="emphasis"><em>средства</em></span>, возможно включающие 
	 грузовики, автопогрузчики, краны, поезда и корабли. Эти средства должны быть в состоянии обрабатывать большое разнообразие грузов 
	 различных размеров и с различными требованиями (напимер, мешки кофе, бочки с опасными химическими веществами, ящики с электронными 
	 товарами, парки высококлассных автомашин, стойки с охлажденной бараниной) Исторически это было обременительным и дорогостоящим 
	 процессом, требующим ручной работы, например, работников доков, для погрузки и выгрузки элементов в каждой точке транзита 
	 <a class="link" href="#Fig0103" target="_top">Рисунок 1-3</a>.</p>
     <div class="figure"><a id="Fig0103"> </a>
      <p class="title"><strong>Рисунок 1.3. Докеры, работающие в Бристоле, Англия (фотография фотоотдела Министерства инфрмации)</strong></p>
      <div class="figure-contents"><div class="mediaobject">
       <img src="figures/Fig0103.jpg" width="505" height="401"/><br />
       <span></span>
      </div></div>
     </div><br class="figure-break"/>
	 <p>Индустрия транспорта пережила революцию с введением многоцелевых контейнеров. Такие контейнеры получили стандартизованные размеры 
	 и были разработаны для перемещения между различными видами транспорта с минимальным применением работников. Все транспортные средства 
	 разрабатываются под эти контейнеры, начиная с погрузчиков и кранов вплоть до грузовиков, поездов и судов. Холодильные и 
	 изотермические контейнеры для транспортировки чувствительных к температуре товаров, например, продуктов питания и фармацевтики. 
	 Преимущества стандартизации также были распространены и на другие системы сопровождения, например, на маркировку и опечатывание 
	 контейнеров. Это означало, что транспортная отрасль может позволить производителям товаров не беспокоиться о содержимом контейнеров, 
	 а следовательно сосредоточиться на перемещении и хранении их контейнеров самих по себе.</p>
	 <p>Цель Docker состоит в переносе преимуществ стандартизации контейнеров в информационные технологии. В последние годы системы 
	 программного обеспечения переживают взрыв в в терминах разнообразия. Прошли те времена когда стек LAMP (изначально обозначало Linux, 
	 Apache, MySQL и PHP - общеупотребимые компоненты веб- приложений) работал на отдельной машине. Типичная современная система может 
	 содержать инфраструктуру Javascript, базы данных NoSQL, очереди сообщений, REST API, а также сервера, написанные на различных языках 
	 программирования. Такой стек должен работать частично или полностью поверх разнообразных аппаратных средств - от ноутбуков разработчиков 
	 и домашних тестовых кластеров вплоть до промышленных поставщиков облачных решений. Каждая из таких сред является существенно отличной, 
	 работает с разными операционными системами, с различными версиями библиотек на различных аппаратных средствах. Короче говоря, мы 
	 имеем аналогичную проблему, которая наблюдалась в транспортной отрасли - мы должны постоянно вносить существенный ручной труд 
	 для перемещения кода между окружениями. Подобно тому как многофункциональные контейнеры упростили транспортировку товаров, 
	 контейнеры Docker упрощают транспортировку программных приложений. Разработчики могут сосредоточиться на разработке приложений и 
	 отправлять его сквозь тестирование и производств не заботясь о разнице в средах и зависимостях. Персонал сопровождения может 
	 сосредоточиться на ключевых вопросах работающих контейнеров, таких как распределение ресурсов запуск и останов контейнеров, а 
	 также их переносе между серверами.</p>
	 </td></tr></table>
   </div>
  </div>

  <div class="section">
   <div xmlns="" class="titlepage"><div><div>
    <h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="01.3"> </a>Docker: история</h3>
   </div></div></div>
   <p>В 2008г Соломон Хайкс основал dotCloud для построения независимого от языков высокого уровня предложения платформы-как-службы (PaaS, 
   Plaftform-as-a-Service). Независимый от языков высокого уровня подход был уникальной посевной точкой для dotCloud - существовавшие PaaS 
   привязывались к определенному набору языков (например, Heroku поддерживал Ruby, а Google App Engine поддерживал Java и Python). 
   В 2010 dotCloud принял участие в программе ускорителя Y Combinator, в которой он был представлен новым партнерам и начал получать 
   серъёзные инвестиции. Главной поворотной точкой стал март 2013, когда dotCloud открыл исходные коды Docker, основной блок построения 
   dotCloud. Хотя некоторые компании были напуганы что dotCloud раздавал свои волшебные бобы, dotCloud осознал, что Docker получит 
   значительную выгоду от того, что станет проектом движимым сообществом.</p>
   <p>Ранние версии Docker были чем-то чуть большим чем обёртка вокруг LXC спаренной с UnionFS, однако освоение и скорость разработки 
   были шокирующе быстрыми. За шесть месяцев он получил 6700зезд на GitHub и 175 свободных сотрудников. Это привело к тому, что dotCloud 
   изменил своё имя на Docker, Inc. и поменял свою бизнес модель. Docker 1.0 был анонсирован в июне 2014, всего через 15 месяцев после 
   выпуска 0.1. Docker 1.0 представил значительный прыжок в стабильности и гибкости - он был теперь объявлен как &quot;годный к 
   промышленному применению&quot;, хотя он уже был замечен в промышленном применении в различных компаниях, включая Spotify и Baidu. 
   В то же время Docker запустил перемещение по направлению к тому чтобы быть завершенной платформой, а не просто движком контейнеров, с 
   запуском Docker Hub, общедоступного репозитория для контейнеров.</p>
   <p>Другиекомпании быстро увидели потенциал Docker. Red Hat стал ведущим партнером в сентябре 2013 и начал применять Docker для 
   усиления своего облачного предложения OpenShift. Google, Amazon и DigitalOcean быстро предложили поддержку Docker в своих облаках, а 
   различные стартапы начали специализироваться на хостинге Docker, например, StackDock. В октябре 2014 Microsoft анонсировал, что последующие 
   версии Windows Server будут поддерживать Docker, отображая колоссальный сдвиг в позиционировании для компании, традиционно связываемой с 
   обрюзгшим корпоративным программным обеспечением.</p>
   <p>В декабре 2014 DockerConEU увидел анонс Docker Swarm, менеджер кластера для Docker и Docker Machine, инструментарий командной строки 
   для предоставления хостов Docker. Это был ясный сигнал намерения Docker предоставить полное и интегрированное решение для работы 
   контейнеров и не позволять себе ограничиваться исключительной поддержкой движка Docker.</p>
   <p>Также в декабре CoreOS анонсировал разработку rkt, своего собственного средства поддержки контейнеров, и разработку спецификации 
   контейнера appc. В июне 2015 на протяжении DockerCon в Сан Франциско, Соломон Хейкс из Docker и Алекс Полви из CoreOS анонсировали 
   инициативы открытого контейнера (затем названную Open Container Project) для разработки общего стандарта для форматов контейнеров и их 
   исполнения.</p>
   <p>Также в июне 2015 проект FreeBSD анонсировал, что Docker теперь поддерживается FreeBSD с применением ZFS и уровня совместимости с 
   Linux. В августе 2015 Docker и Microsoft выпустили &quot;технический предпоказ&quot; Docker Engine для Windows Server.</p>
   <p>Начиная с выпуска Docker 1.8, Docker ввёл функциональность доверия содержимому, которая проверяет целостность и издателя образов 
   Docker. Доверие содержимому является критически важным компонентом для построения доверенных инфраструктур основанных на образах, 
   получаемых из реестров Docker.</p>
  </div>
   
  <div class="section">
   <div xmlns="" class="titlepage"><div><div>
    <h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="01.4"> </a>Плагины и сантехника</h3>
   </div></div></div>
   <p>Будучи компанией, Docker Inc. неизменно быстро осознавала, что во многом обязана своим успехом экосистеме. В то время как 
   Docker Inc. сосредотачивается на выпуске стабильной, готовой к промышленной эксплуатации версии движка контейнеров, другие 
   компании, такие как CoreOS, WeaveWorks и ClusterHQ работали в смежных областях, например, оркестровка и сетевые контейнеры. Однако 
   быстро стало понятно, что Docker Inc. планировала производить завершённую коробочную платформу, содержащую сетевую среду, 
   хранилище и возможности оркестровки. С целью поощрения дальнейшего роста экосистемы и гарантирования пользователям наличия доступа 
   к решениям для широкого диапазона вариантов применения, Docker Inc. объявила о своём намерении создать модульную расширяемую 
   инфраструктуру для Docker, в которой имеющиеся в наличии компоненты могут выгружаться для сторонних эквивалентов или расширяться 
   сторонней функциональностью. Docker Inc. назвал эту стратегию &quot;батарейки в комплекте, но заменяемы&quot; (Batteries Included, 
   But Replaceable), что означает, что полные решения будут предоставлены, но детали могут переставляться (конкретно мне никогда не 
   нравилась данная фраза, все батарейки предоставляют во многом схожую функциональность, и могут заменяться только батареями того 
   же размера и напряжения; я предполагаю, что эта фраза имеет происхождение из Python-овской философии &quot;батарейки вложены&quot;
   (Batteries Included), которая используется для объяснения громадной стандартной библиотеки, поставляемой с Python).</p>
   <p>На момент написания книги инфраструктура подключаемых модулей находится в младенческом возрасте, но уже доступна. Существует 
   несколько подключаемых модулей уже доступных для контейнеров сетевой среды и управления данными.</p>
   <p>Docker также следует тому, что они называют &quot;манифестом сантехнической инфраструктуры&quot; (Infrastructure Plumbing 
   Manifesto), который подчеркивает свою приверженность повторному использованию и совершенствованию существующих компонентов 
   инфраструктуры там, где это возможно и способствует повторному использованию компонентов обратно в сообществе, когда 
   требуются новые инструменты. Это привело к вывинчиванию кода низкого уровня для выполнения контейнеров в проект 
   <span class="emphasis"><em>runC</em></span>, который контролируется OCI и может повторно применяться как основа для других 
   платформ контейнера.</p>
  </div>

  <div class="section">
   <div xmlns="" class="titlepage"><div><div>
    <h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="01.5"> </a>Linux 64-бита</h3>
   </div></div></div>
   <p>На момент написания единственная стабильная, готовая к промышленной эксплуатации платформа для Docker была 64- битный Linux. 
   Это означает, что ваш компьютер должен выполнять 64- битный дистрибутив Linux и все контейнеры также будут 64- битные Linux. Если 
   вы являетесь пользователем Windows или Mac OS, вы можете выполнять Docker внутри виртуальной машины.</p>
   <p>Поддержка для других обычных контейнеров на других платформах, включающих BSD, Solaris и Windows Server находятся в различных 
   стадиях разработки. Хотя Docker не делал изначально никакой виртуализации, контейнеры всегда должны соответствовать ядру хоста - 
   Windows Server контейнер может выполняться только на Windows Server хосте, а 64- битный Linux контейнер может работать только на 
   64- битном Linux хосте.</p>
       <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
	   <table border="0" summary="Замечание"><tr><td rowspan="2" align="center" valign="top" width="25"><a id="MicroservicesAndMonoliths"> </a>
	   <img alt="[Замечание]" src="../common/images/admon/note.png"/></td><th align="left">Микрослужбы и монолиты</th></tr><tr><td align="left" valign="top">
	   <p>Одним из крупнейших прецедентов, а также самые мощные драйверы в основе потребления контейнеров являются 
	   <span class="emphasis"><em>микрослужбы</em></span>.</p>
	   <p>Микрослужбы являются способом разработки и составления программных систем таким образом, что они строятся из небольших независимых 
	   компонентов, которые взаимодействуют друг с другом через сетевую среду. Это противопоставляется традиционному 
	   <span class="emphasis"><em>монолитному</em></span> способу разработки программного обеспечения, при котором существует отдельная 
	   большая программа, обычно написанная на C++ или Java.</p>
	   <p>Когда приходится масштабировать монолит, обычно единственный способ заключается в <span class="emphasis"><em>увеличении 
	   масштаба</em></span>, когда дополнительные потребности обрабатываются при помощи большей машины или большего объёма оперативной 
	   памяти и мощности процессоров. Микрослужбы же, наоборот, разработаны для <span class="emphasis"><em>масштабирования 
	   вовне</em></span>, при котором дополнительные потребности обрабатываются предоставлением множества машин, по которым может 
	   распределяться нагрузка. При архитектуре микрослужб можно масштабировать только ресурсы, необходимые для определённой службы, 
	   сосредотачиваясь на узких местах в системе. В случае монолита масштабируется всё или ничего, что приводит к ненужным 
	   затратам ресурсов.</p>
	   <p>С точки зрения сложности микрослужбы являются обоюдоострым мечом. Каждую отдельную службу необходимо легко понимать и изменять.
	   Тем не менее, в системе, состоящей из десятков и сотен подобных служб за счёт взаимодействия между отдельными компонентами 
	   увеличивается общая сложность.</p>
	   <p>Присущие лёгкий вес и скорость контейнеров означают, что они особенно хороши для работы с архитектурой микрослужб. В сравнении с 
	   ВМ, контейнеры чрезвычайно меньше и быстрее для развёртывания, позволяя архитектуре микрослужб использовать минимум ресурсов и 
	   быстро реагировать на изменения по запросу.</p>
	   <p>Для получения дополнительных сведений по микрослужбам ознакомьтесь с <a class="link" href="http://shop.oreilly.com/product/0636920033158.do" 
	   target="_top">Building Microservices</a> Сэма Ньюмана (O`Reilly) и <a class="link" href="http://martinfowler.com/microservices/" 
	   target="_top">Microservice Resource Guide</a> Мартина Фоулера.</p>
	   </td></tr></table>
     </div>
</div>

</div>

<!----><script type="text/javascript" src="FooterAndSidebar.js">
</script><script type="text/javascript"><!--</div id="content"> is inside next code
document.write(FooterAndSidebar);//-->
</script>

</body></html>